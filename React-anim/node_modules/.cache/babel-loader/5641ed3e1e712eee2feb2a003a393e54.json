{"ast":null,"code":"import { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, useLayoutEffect, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport { forwardRef, useRef, useCallback, useEffect, createElement } from 'react';\nconst $node = Symbol.for(\"Animated:node\");\n\nconst isAnimated = value => !!value && value[$node] === value;\n\nconst getAnimated = owner => owner && owner[$node];\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\n\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.durationProgress = 0;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  dependencies: null\n};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.some((node, i) => node.setValue(source[i]));\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n}\n\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useLayoutEffect(() => {\n      const lastObserver = observerRef.current;\n      observerRef.current = observer;\n      each(deps, dep => addFluidObserver(dep, observer));\n\n      if (lastObserver) {\n        each(lastObserver.deps, dep => removeFluidObserver(dep, lastObserver));\n        raf.cancel(lastObserver.update);\n      }\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer2 = observerRef.current;\n      each(observer2.deps, dep => removeFluidObserver(dep, observer2));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */createElement(Component, { ...usedProps,\n      ref\n    });\n  });\n};\n\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      raf.write(this.update);\n    }\n  }\n\n}\n\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = { ...props,\n    style: host.createAnimatedStyle(props.style)\n  };\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nconst cacheKey = Symbol.for(\"AnimatedComponent\");\n\nconst createHost = function (components) {\n  let {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || \"Anonymous\";\n\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"mappings":"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","names":["$node","Symbol","for","value","owner","defineHidden","node","getPayload","constructor","setAnimated","payload","Animated2","_value","is","num","lastPosition","AnimatedValue","getValue","setValue","step","Math","round","done","reset","elapsedTime","durationProgress","lastVelocity","v0","AnimatedValue2","_toString","createInterpolator","output","AnimatedString","_string","str","goal","TreeContext","dependencies","source","eachProp","isAnimated","values","key","animated","hasFluidValue","getFluidValue","_makePayload","each","Set","_addToPayload","Array","from","add","AnimatedObject2","AnimatedArray","map","length","some","i","makeAnimated","isAnimatedString","AnimatedString2","nodeType","create","getAnimated","parentNode","arr","AnimatedArray2","withAnimated","fun","Component","prototype","isReactComponent","forwardRef","useRef","hasInstance","useCallback","instanceRef","current","updateRef","givenRef","getAnimatedState","givenProps","host","useForceUpdate","instance","applyAnimatedValues","props","didUpdate","forceUpdate","PropsObserver","callback","deps","useLayoutEffect","observerRef","observer","dep","addFluidObserver","lastObserver","removeFluidObserver","raf","cancel","update","useEffect","useOnce","observer2","getComponentProps","usedProps","ref","eventObserved","event","type","write","style","createAnimatedStyle","cacheKey","getDisplayName","withAnimated2","hostConfig","displayName","components","arg","name"],"sources":["/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/Animated.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/AnimatedValue.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/AnimatedString.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/context.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/AnimatedObject.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/AnimatedArray.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/getAnimatedType.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/withAnimated.tsx","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/animated/src/createHost.ts"],"sourcesContent":["import { defineHidden } from '@react-spring/shared'\nimport { AnimatedValue } from './AnimatedValue'\n\nconst $node: any = Symbol.for('Animated:node')\n\nexport const isAnimated = <T = any>(value: any): value is Animated<T> =>\n  !!value && value[$node] === value\n\n/** Get the owner's `Animated` node. */\nexport const getAnimated = <T = any>(owner: any): Animated<T> | undefined =>\n  owner && owner[$node]\n\n/** Set the owner's `Animated` node. */\nexport const setAnimated = (owner: any, node: Animated) =>\n  defineHidden(owner, $node, node)\n\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\nexport const getPayload = (owner: any): AnimatedValue[] | undefined =>\n  owner && owner[$node] && owner[$node].getPayload()\n\nexport abstract class Animated<T = any> {\n  /** The cache of animated values */\n  protected payload?: Payload\n\n  constructor() {\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this)\n  }\n\n  /** Get the current value. Pass `true` for only animated values. */\n  abstract getValue(animated?: boolean): T\n\n  /** Set the current value. Returns `true` if the value changed. */\n  abstract setValue(value: T): boolean | void\n\n  /** Reset any animation state. */\n  abstract reset(goal?: T): void\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload(): Payload {\n    return this.payload || []\n  }\n}\n\nexport type Payload = readonly AnimatedValue[]\n","import { is } from '@react-spring/shared'\nimport { Animated, Payload } from './Animated'\n\n/** An animated number or a native attribute value */\nexport class AnimatedValue<T = any> extends Animated {\n  done = true\n  elapsedTime!: number\n  lastPosition!: number\n  lastVelocity?: number | null\n  v0?: number | null\n  durationProgress = 0\n\n  constructor(protected _value: T) {\n    super()\n    if (is.num(this._value)) {\n      this.lastPosition = this._value\n    }\n  }\n\n  /** @internal */\n  static create(value: any) {\n    return new AnimatedValue(value)\n  }\n\n  getPayload(): Payload {\n    return [this]\n  }\n\n  getValue() {\n    return this._value\n  }\n\n  setValue(value: T, step?: number) {\n    if (is.num(value)) {\n      this.lastPosition = value\n      if (step) {\n        value = (Math.round(value / step) * step) as any\n        if (this.done) {\n          this.lastPosition = value as any\n        }\n      }\n    }\n    if (this._value === value) {\n      return false\n    }\n    this._value = value\n    return true\n  }\n\n  reset() {\n    const { done } = this\n    this.done = false\n    if (is.num(this._value)) {\n      this.elapsedTime = 0\n      this.durationProgress = 0\n      this.lastPosition = this._value\n      if (done) this.lastVelocity = null\n      this.v0 = null\n    }\n  }\n}\n","import { AnimatedValue } from './AnimatedValue'\nimport { is, createInterpolator } from '@react-spring/shared'\n\ntype Value = string | number\n\nexport class AnimatedString extends AnimatedValue<Value> {\n  protected _value!: number\n  protected _string: string | null = null\n  protected _toString: (input: number) => string\n\n  constructor(value: string) {\n    super(0)\n    this._toString = createInterpolator({\n      output: [value, value],\n    })\n  }\n\n  /** @internal */\n  static create(value: string) {\n    return new AnimatedString(value)\n  }\n\n  getValue() {\n    let value = this._string\n    return value == null ? (this._string = this._toString(this._value)) : value\n  }\n\n  setValue(value: Value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false\n      }\n      this._string = value\n      this._value = 1\n    } else if (super.setValue(value)) {\n      this._string = null\n    } else {\n      return false\n    }\n    return true\n  }\n\n  reset(goal?: string) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal],\n      })\n    }\n    this._value = 0\n    super.reset()\n  }\n}\n","import { FluidValue } from '@react-spring/shared'\n\nexport type TreeContext = {\n  /**\n   * Any animated values found when updating the payload of an `AnimatedObject`\n   * are also added to this `Set` to be observed by an animated component.\n   */\n  dependencies: Set<FluidValue> | null\n}\n\nexport const TreeContext: TreeContext = { dependencies: null }\n","import { Lookup } from '@react-spring/types'\nimport {\n  each,\n  eachProp,\n  getFluidValue,\n  hasFluidValue,\n} from '@react-spring/shared'\nimport { Animated, isAnimated, getPayload } from './Animated'\nimport { AnimatedValue } from './AnimatedValue'\nimport { TreeContext } from './context'\n\n/** An object containing `Animated` nodes */\nexport class AnimatedObject extends Animated {\n  constructor(protected source: Lookup) {\n    super()\n    this.setValue(source)\n  }\n\n  getValue(animated?: boolean) {\n    const values: Lookup = {}\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated)\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source)\n      } else if (!animated) {\n        values[key] = source\n      }\n    })\n    return values\n  }\n\n  /** Replace the raw object data */\n  setValue(source: Lookup) {\n    this.source = source\n    this.payload = this._makePayload(source)\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset())\n    }\n  }\n\n  /** Create a payload set. */\n  protected _makePayload(source: Lookup) {\n    if (source) {\n      const payload = new Set<AnimatedValue>()\n      eachProp(source, this._addToPayload, payload)\n      return Array.from(payload)\n    }\n  }\n\n  /** Add to a payload set. */\n  protected _addToPayload(this: Set<AnimatedValue>, source: any) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source)\n    }\n    const payload = getPayload(source)\n    if (payload) {\n      each(payload, node => this.add(node))\n    }\n  }\n}\n","import { isAnimatedString } from '@react-spring/shared'\nimport { AnimatedObject } from './AnimatedObject'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\n\ntype Value = number | string\ntype Source = AnimatedValue<Value>[]\n\n/** An array of animated nodes */\nexport class AnimatedArray<\n  T extends ReadonlyArray<Value> = Value[]\n> extends AnimatedObject {\n  protected source!: Source\n  constructor(source: T) {\n    super(source)\n  }\n\n  /** @internal */\n  static create<T extends ReadonlyArray<Value>>(source: T) {\n    return new AnimatedArray(source)\n  }\n\n  getValue(): T {\n    return this.source.map(node => node.getValue()) as any\n  }\n\n  setValue(source: T) {\n    const payload = this.getPayload()\n    // Reuse the payload when lengths are equal.\n    if (source.length == payload.length) {\n      return payload.some((node, i) => node.setValue(source[i]))\n    }\n    // Remake the payload when length changes.\n    super.setValue(source.map(makeAnimated))\n    return true\n  }\n}\n\nfunction makeAnimated(value: any) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue\n  return nodeType.create(value)\n}\n","import { is, isAnimatedString } from '@react-spring/shared'\nimport { AnimatedType } from './types'\nimport { AnimatedArray } from './AnimatedArray'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\nimport { getAnimated } from './Animated'\n\n/** Return the `Animated` node constructor for a given value */\nexport function getAnimatedType(value: any): AnimatedType {\n  const parentNode = getAnimated(value)\n  return parentNode\n    ? (parentNode.constructor as any)\n    : is.arr(value)\n    ? AnimatedArray\n    : isAnimatedString(value)\n    ? AnimatedString\n    : AnimatedValue\n}\n","import * as React from 'react'\nimport { forwardRef, useRef, Ref, useCallback, useEffect } from 'react'\nimport {\n  is,\n  each,\n  raf,\n  useForceUpdate,\n  useOnce,\n  FluidEvent,\n  FluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n  useLayoutEffect,\n} from '@react-spring/shared'\nimport { ElementType } from '@react-spring/types'\n\nimport { AnimatedObject } from './AnimatedObject'\nimport { TreeContext } from './context'\nimport { HostConfig } from './createHost'\n\nexport type AnimatableComponent = string | Exclude<ElementType, string>\n\nexport const withAnimated = (Component: any, host: HostConfig) => {\n  const hasInstance: boolean =\n    // Function components must use \"forwardRef\" to avoid being\n    // re-rendered on every animation frame.\n    !is.fun(Component) ||\n    (Component.prototype && Component.prototype.isReactComponent)\n\n  return forwardRef((givenProps: any, givenRef: Ref<any>) => {\n    const instanceRef = useRef<any>(null)\n\n    // The `hasInstance` value is constant, so we can safely avoid\n    // the `useCallback` invocation when `hasInstance` is false.\n    const ref =\n      hasInstance &&\n      useCallback(\n        (value: any) => {\n          instanceRef.current = updateRef(givenRef, value)\n        },\n        [givenRef]\n      )\n\n    const [props, deps] = getAnimatedState(givenProps, host)\n\n    const forceUpdate = useForceUpdate()\n\n    const callback = () => {\n      const instance = instanceRef.current\n      if (hasInstance && !instance) {\n        // Either this component was unmounted before changes could be\n        // applied, or the wrapped component forgot to forward its ref.\n        return\n      }\n\n      const didUpdate = instance\n        ? host.applyAnimatedValues(instance, props.getValue(true))\n        : false\n\n      // Re-render the component when native updates fail.\n      if (didUpdate === false) {\n        forceUpdate()\n      }\n    }\n\n    const observer = new PropsObserver(callback, deps)\n\n    const observerRef = useRef<PropsObserver>()\n    useLayoutEffect(() => {\n      const lastObserver = observerRef.current\n      observerRef.current = observer\n\n      // Observe the latest dependencies.\n      each(deps, dep => addFluidObserver(dep, observer))\n\n      // Stop observing previous dependencies.\n      if (lastObserver) {\n        each(lastObserver.deps, dep => removeFluidObserver(dep, lastObserver))\n        raf.cancel(lastObserver.update)\n      }\n    })\n\n    useEffect(callback, [])\n    // Stop observing on unmount.\n    useOnce(() => () => {\n      const observer = observerRef.current!\n      each(observer.deps, dep => removeFluidObserver(dep, observer))\n    })\n\n    const usedProps = host.getComponentProps(props.getValue())\n    return <Component {...usedProps} ref={ref} />\n  })\n}\n\nclass PropsObserver {\n  constructor(readonly update: () => void, readonly deps: Set<FluidValue>) {}\n  eventObserved(event: FluidEvent) {\n    if (event.type == 'change') {\n      raf.write(this.update)\n    }\n  }\n}\n\ntype AnimatedState = [props: AnimatedObject, dependencies: Set<FluidValue>]\n\nfunction getAnimatedState(props: any, host: HostConfig): AnimatedState {\n  const dependencies = new Set<FluidValue>()\n  TreeContext.dependencies = dependencies\n\n  // Search the style for dependencies.\n  if (props.style)\n    props = {\n      ...props,\n      style: host.createAnimatedStyle(props.style),\n    }\n\n  // Search the props for dependencies.\n  props = new AnimatedObject(props)\n\n  TreeContext.dependencies = null\n  return [props, dependencies]\n}\n\nfunction updateRef<T>(ref: Ref<T>, value: T) {\n  if (ref) {\n    if (is.fun(ref)) ref(value)\n    else (ref as any).current = value\n  }\n  return value\n}\n","import { Lookup } from '@react-spring/types'\nimport { is, eachProp } from '@react-spring/shared'\nimport { AnimatableComponent, withAnimated } from './withAnimated'\nimport { Animated } from './Animated'\nimport { AnimatedObject } from './AnimatedObject'\n\nexport interface HostConfig {\n  /** Provide custom logic for native updates */\n  applyAnimatedValues: (node: any, props: Lookup) => boolean | void\n  /** Wrap the `style` prop with an animated node */\n  createAnimatedStyle: (style: Lookup) => Animated\n  /** Intercept props before they're passed to an animated component */\n  getComponentProps: (props: Lookup) => typeof props\n}\n\n// A stub type that gets replaced by @react-spring/web and others.\ntype WithAnimated = {\n  (Component: AnimatableComponent): any\n  [key: string]: any\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent')\n\nexport const createHost = (\n  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },\n  {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props,\n  }: Partial<HostConfig> = {}\n) => {\n  const hostConfig: HostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps,\n  }\n\n  const animated: WithAnimated = (Component: any) => {\n    const displayName = getDisplayName(Component) || 'Anonymous'\n\n    if (is.str(Component)) {\n      Component =\n        animated[Component] ||\n        (animated[Component] = withAnimated(Component, hostConfig))\n    } else {\n      Component =\n        Component[cacheKey] ||\n        (Component[cacheKey] = withAnimated(Component, hostConfig))\n    }\n\n    Component.displayName = `Animated(${displayName})`\n    return Component\n  }\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component)!\n    }\n    animated[key] = animated(Component)\n  })\n\n  return {\n    animated,\n  }\n}\n\nconst getDisplayName = (arg: AnimatableComponent) =>\n  is.str(arg)\n    ? arg\n    : arg && is.str(arg.displayName)\n    ? arg.displayName\n    : (is.fun(arg) && arg.name) || null\n"]},"metadata":{},"sourceType":"module"}