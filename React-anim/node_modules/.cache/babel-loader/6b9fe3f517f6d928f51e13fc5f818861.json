{"ast":null,"code":"let updateQueue = makeQueue();\n\nconst raf = fn => schedule(fn, updateQueue);\n\nlet writeQueue = makeQueue();\n\nraf.write = fn => schedule(fn, writeQueue);\n\nlet onStartQueue = makeQueue();\n\nraf.onStart = fn => schedule(fn, onStartQueue);\n\nlet onFrameQueue = makeQueue();\n\nraf.onFrame = fn => schedule(fn, onFrameQueue);\n\nlet onFinishQueue = makeQueue();\n\nraf.onFinish = fn => schedule(fn, onFinishQueue);\n\nlet timeouts = [];\n\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\n\nraf.cancel = fn => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = fn => {\n  let lastArgs;\n\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nlet nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : () => {};\n\nraf.use = impl => nativeRaf = impl;\n\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\n\nraf.batchedUpdates = fn => fn();\n\nraf.catch = console.error;\nlet ts = -1;\nlet sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nconst __raf = {\n  count: 0,\n\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n\n};\nexport { __raf, raf };","map":{"version":3,"mappings":"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","names":["updateQueue","makeQueue","fn","schedule","raf","write","writeQueue","onStart","onStartQueue","onFrame","onFrameQueue","onFinish","onFinishQueue","setTimeout","now","ms","timeouts","findIndex","t","cancel","i","splice","__raf","count","time","handler","findTimeout","timeout","start","length","delete","sync","batchedUpdates","throttle","lastArgs","args","queuedFn","throttled","window","requestAnimationFrame","use","impl","nativeRaf","performance","Date","catch","console","error","queue","add","ts","loop","update","eachSafely","flush","prevTs","Math","min","Set","next","current","has","size","arg","values","forEach","value","each","e","clear"],"sources":["/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/rafz/src/raf.ts"],"sourcesContent":["import type {\n  FrameFn,\n  FrameUpdateFn,\n  NativeRaf,\n  Rafz,\n  Timeout,\n  Throttled,\n} from './types'\n\nexport { FrameFn, FrameUpdateFn, Timeout, Throttled }\n\nlet updateQueue = makeQueue<FrameUpdateFn>()\n\n/**\n * Schedule an update for next frame.\n * Your function can return `true` to repeat next frame.\n */\nexport const raf: Rafz = fn => schedule(fn, updateQueue)\n\nlet writeQueue = makeQueue<FrameFn>()\nraf.write = fn => schedule(fn, writeQueue)\n\nlet onStartQueue = makeQueue<FrameFn>()\nraf.onStart = fn => schedule(fn, onStartQueue)\n\nlet onFrameQueue = makeQueue<FrameFn>()\nraf.onFrame = fn => schedule(fn, onFrameQueue)\n\nlet onFinishQueue = makeQueue<FrameFn>()\nraf.onFinish = fn => schedule(fn, onFinishQueue)\n\nlet timeouts: Timeout[] = []\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel)\n    if (~i) timeouts.splice(i, 1)\n    __raf.count -= ~i ? 1 : 0\n  }\n\n  let timeout: Timeout = { time, handler, cancel }\n  timeouts.splice(findTimeout(time), 0, timeout)\n  __raf.count += 1\n\n  start()\n  return timeout\n}\n\n/** Find the index where the given time is not greater. */\nlet findTimeout = (time: number) =>\n  ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length)\n\nraf.cancel = fn => {\n  updateQueue.delete(fn)\n  writeQueue.delete(fn)\n}\n\nraf.sync = fn => {\n  sync = true\n  raf.batchedUpdates(fn)\n  sync = false\n}\n\nraf.throttle = fn => {\n  let lastArgs: any\n  function queuedFn() {\n    try {\n      fn(...lastArgs)\n    } finally {\n      lastArgs = null\n    }\n  }\n  function throttled(...args: any) {\n    lastArgs = args\n    raf.onStart(queuedFn)\n  }\n  throttled.handler = fn\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn)\n    lastArgs = null\n  }\n  return throttled as any\n}\n\nlet nativeRaf =\n  typeof window != 'undefined'\n    ? (window.requestAnimationFrame as NativeRaf)\n    : () => {}\n\nraf.use = impl => (nativeRaf = impl)\nraf.now = typeof performance != 'undefined' ? () => performance.now() : Date.now\nraf.batchedUpdates = fn => fn()\nraf.catch = console.error\n\n/** The most recent timestamp. */\nlet ts = -1\n\n/** When true, scheduling is disabled. */\nlet sync = false\n\nfunction schedule<T extends Function>(fn: T, queue: Queue<T>) {\n  if (sync) {\n    queue.delete(fn)\n    fn(0)\n  } else {\n    queue.add(fn)\n    start()\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0\n    nativeRaf(loop)\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop)\n    raf.batchedUpdates(update)\n  }\n}\n\nfunction update() {\n  let prevTs = ts\n  ts = raf.now()\n\n  // Flush timeouts whose time is up.\n  let count = findTimeout(ts)\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler())\n    __raf.count -= count\n  }\n\n  onStartQueue.flush()\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667)\n  onFrameQueue.flush()\n  writeQueue.flush()\n  onFinishQueue.flush()\n}\n\ninterface Queue<T extends Function = any> {\n  add: (fn: T) => void\n  delete: (fn: T) => boolean\n  flush: (arg?: any) => void\n}\n\nfunction makeQueue<T extends Function>(): Queue<T> {\n  let next = new Set<T>()\n  let current = next\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0\n      next.add(fn)\n    },\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0\n      return next.delete(fn)\n    },\n    flush(arg) {\n      if (current.size) {\n        next = new Set()\n        __raf.count -= current.size\n        eachSafely(current, fn => fn(arg) && next.add(fn))\n        __raf.count += next.size\n        current = next\n      }\n    },\n  }\n}\n\ninterface Eachable<T> {\n  forEach(cb: (value: T) => void): void\n}\n\nfunction eachSafely<T>(values: Eachable<T>, each: (value: T) => void) {\n  values.forEach(value => {\n    try {\n      each(value)\n    } catch (e) {\n      raf.catch(e)\n    }\n  })\n}\n\n/** Tree-shakable state for testing purposes */\nexport const __raf = {\n  /** The number of pending tasks */\n  count: 0,\n  /** Clear internal state. Never call from update loop! */\n  clear() {\n    ts = -1\n    timeouts = []\n    onStartQueue = makeQueue()\n    updateQueue = makeQueue()\n    onFrameQueue = makeQueue()\n    writeQueue = makeQueue()\n    onFinishQueue = makeQueue()\n    __raf.count = 0\n  },\n}\n"]},"metadata":{},"sourceType":"module"}