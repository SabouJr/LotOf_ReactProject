{"ast":null,"code":"import { eachProp, is, toArray, isAnimatedString, Globals, getFluidValue, useLayoutEffect, each, raf, flush, FluidValue, deprecateInterpolate, callFluidObservers, frameLoop, hasFluidValue, flushCalls, isEqual, getFluidObservers, addFluidObserver, removeFluidObserver, noop, useMemoOne, deprecateDirectCall, useForceUpdate, usePrev, useOnce, createInterpolator, createStringInterpolator } from '@react-spring/shared';\nexport { Globals, createInterpolator } from '@react-spring/shared';\nimport { useContext, createElement, createContext, useMemo, useRef, useState, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, AnimatedString, getAnimatedType, setAnimated } from '@react-spring/animated';\nexport * from '@react-spring/types/animated';\nexport * from '@react-spring/types/interpolation';\n\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(value) ? value(...args) : value;\n}\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n\nconst resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;\n\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;\n\nconst noopTransform = value => value;\n\nconst getDefaultProps = function (props) {\n  let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noopTransform;\n  let keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  const defaults = {};\n\n  for (const key of keys) {\n    const value = transform(props[key], key);\n\n    if (!is.und(value)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\n\nconst DEFAULT_PROPS = [\"config\", \"onProps\", \"onStart\", \"onChange\", \"onPause\", \"onResume\", \"onRest\"];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  eachProp(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n\n  if (to) {\n    const out = {\n      to\n    };\n    eachProp(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n\n  return { ...props\n  };\n}\n\nfunction computeGoal(value) {\n  value = getFluidValue(value);\n  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? Globals.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nfunction hasProps(props) {\n  for (const _ in props) return true;\n\n  return false;\n}\n\nfunction isAsyncTo(to) {\n  return is.fun(to) || is.arr(to) && is.obj(to[0]);\n}\n\nfunction detachRefs(ctrl, ref) {\n  var _a;\n\n  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n  ref == null ? void 0 : ref.delete(ctrl);\n}\n\nfunction replaceRef(ctrl, ref) {\n  var _a;\n\n  if (ref && ctrl.ref !== ref) {\n    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n    ref.add(ctrl);\n    ctrl.ref = ref;\n  }\n}\n\nfunction useChain(refs, timeSteps) {\n  let timeFrame = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e3;\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i];\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              const memoizedDelayProp = props.delay;\n\n              props.delay = key => delay + callProp(memoizedDelayProp || 0, key);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          const queues = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          });\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => each(queues[i] || [], update => ctrl.queue.push(update)));\n            return ref.start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst linear = t => t;\n\nconst defaults = { ...config.default,\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n};\n\nclass AnimationConfig {\n  constructor() {\n    this.velocity = 0;\n    Object.assign(this, defaults);\n  }\n\n}\n\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = { ...defaultConfig\n    };\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = { ...defaultConfig,\n      ...newConfig\n    };\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n}\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = void 0;\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = void 0;\n      config.decay = void 0;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = void 0;\n    }\n  }\n}\n\nconst emptyArray = [];\n\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n  }\n\n}\n\nfunction scheduleProps(callId, _ref) {\n  let {\n    key,\n    props,\n    defaultProps,\n    state,\n    actions\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    var _a;\n\n    let delay;\n    let timeout;\n    let cancel = matchProp((_a = props.cancel) != null ? _a : defaultProps == null ? void 0 : defaultProps.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      if (!is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key);\n      }\n\n      let pause = defaultProps == null ? void 0 : defaultProps.pause;\n\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key);\n      }\n\n      delay = callProp(props.delay || 0, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      state.timeouts.delete(timeout);\n      timeout.cancel();\n      delay = timeout.time - raf.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        timeout = raf.setTimeout(onStart, delay);\n        state.pauseQueue.add(onPause);\n        state.timeouts.add(timeout);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause);\n      state.timeouts.delete(timeout);\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start({ ...props,\n          callId,\n          cancel\n        }, resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target.get()) : results.every(result => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every(result => result.finished));\n\nconst getNoopResult = value => ({\n  value,\n  noop: true,\n  finished: true,\n  cancelled: false\n});\n\nconst getFinishedResult = function (value, finished) {\n  let cancelled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    value,\n    finished,\n    cancelled\n  };\n};\n\nconst getCancelledResult = value => ({\n  value,\n  cancelled: true,\n  finished: false\n});\n\nfunction runAsync(to, props, state, target) {\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to;\n    const defaultProps = getDefaultProps(props, (value, key) => key === \"onRest\" ? void 0 : value);\n    let preventBail;\n    let bail;\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));\n\n    const bailIfEnded = bailSignal => {\n      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);\n\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        bail(bailSignal);\n        throw bailSignal;\n      }\n    };\n\n    const animate = (arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      const skipAnimationSignal = new SkipAniamtionSignal();\n      return (async () => {\n        if (Globals.skipAnimation) {\n          stopAsync(state);\n          skipAnimationSignal.result = getFinishedResult(target, false);\n          bail(skipAnimationSignal);\n          throw skipAnimationSignal;\n        }\n\n        bailIfEnded(bailSignal);\n        const props2 = is.obj(arg1) ? { ...arg1\n        } : { ...arg2,\n          to: arg1\n        };\n        props2.parentId = callId;\n        eachProp(defaultProps, (value, key) => {\n          if (is.und(props2[key])) {\n            props2[key] = value;\n          }\n        });\n        const result2 = await target.start(props2);\n        bailIfEnded(bailSignal);\n\n        if (state.paused) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n\n        return result2;\n      })();\n    };\n\n    let result;\n\n    if (Globals.skipAnimation) {\n      stopAsync(state);\n      return getFinishedResult(target, false);\n    }\n\n    try {\n      let animating;\n\n      if (is.arr(to)) {\n        animating = (async queue => {\n          for (const props2 of queue) {\n            await animate(props2);\n          }\n        })(to);\n      } else {\n        animating = Promise.resolve(to(animate, target.stop.bind(target)));\n      }\n\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target.get(), true, false);\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else if (err instanceof SkipAniamtionSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      }\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : void 0;\n        state.promise = parentId ? prevPromise : void 0;\n      }\n    }\n\n    if (is.fun(onRest)) {\n      raf.batchedUpdates(() => {\n        onRest(result, target, target.item);\n      });\n    }\n\n    return result;\n  })();\n}\n\nfunction stopAsync(state, cancelId) {\n  flush(state.timeouts, t => t.cancel());\n  state.pauseQueue.clear();\n  state.resumeQueue.clear();\n  state.asyncId = state.asyncTo = state.promise = void 0;\n  if (cancelId) state.cancelId = cancelId;\n}\n\nclass BailSignal extends Error {\n  constructor() {\n    super(\"An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.\");\n  }\n\n}\n\nclass SkipAniamtionSignal extends Error {\n  constructor() {\n    super(\"SkipAnimationSignal\");\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\n\nlet nextId = 1;\n\nclass FrameValue extends FluidValue {\n  constructor() {\n    super(...arguments);\n    this.id = nextId++;\n    this._priority = 0;\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n\n  to() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return Globals.to(this, args);\n  }\n\n  interpolate() {\n    deprecateInterpolate();\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return Globals.to(this, args);\n  }\n\n  toJSON() {\n    return this.get();\n  }\n\n  observerAdded(count) {\n    if (count == 1) this._attach();\n  }\n\n  observerRemoved(count) {\n    if (count == 0) this._detach();\n  }\n\n  _attach() {}\n\n  _detach() {}\n\n  _onChange(value) {\n    let idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    callFluidObservers(this, {\n      type: \"change\",\n      parent: this,\n      value,\n      idle\n    });\n  }\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      frameLoop.sort(this);\n    }\n\n    callFluidObservers(this, {\n      type: \"priority\",\n      parent: this,\n      priority\n    });\n  }\n\n}\n\nconst $P = Symbol.for(\"SpringPhase\");\nconst HAS_ANIMATED = 1;\nconst IS_ANIMATING = 2;\nconst IS_PAUSED = 4;\n\nconst hasAnimated = target => (target[$P] & HAS_ANIMATED) > 0;\n\nconst isAnimating = target => (target[$P] & IS_ANIMATING) > 0;\n\nconst isPaused = target => (target[$P] & IS_PAUSED) > 0;\n\nconst setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\n\nconst setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\n\nclass SpringValue extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    this.animation = new Animation();\n    this.defaultProps = {};\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._pendingCalls = new Set();\n    this._lastCallId = 0;\n    this._lastToId = 0;\n    this._memoizedDuration = 0;\n\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? { ...arg1\n      } : { ...arg2,\n        from: arg1\n      };\n\n      if (is.und(props.default)) {\n        props.default = true;\n      }\n\n      this.start(props);\n    }\n  }\n\n  get idle() {\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\n  }\n\n  get goal() {\n    return getFluidValue(this.animation.to);\n  }\n\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node2 => node2.lastVelocity || 0);\n  }\n\n  get hasAnimated() {\n    return hasAnimated(this);\n  }\n\n  get isAnimating() {\n    return isAnimating(this);\n  }\n\n  get isPaused() {\n    return isPaused(this);\n  }\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = getPayload(anim.to);\n\n    if (!payload && hasFluidValue(anim.to)) {\n      toValues = toArray(getFluidValue(anim.to));\n    }\n\n    anim.values.forEach((node2, i) => {\n      if (node2.done) return;\n      const to = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n\n      if (!finished) {\n        position = node2.lastPosition;\n\n        if (config.tension <= 0) {\n          node2.done = true;\n          return;\n        }\n\n        let elapsed = node2.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity;\n\n        if (!is.und(config.duration)) {\n          let p = 1;\n\n          if (config.duration > 0) {\n            if (this._memoizedDuration !== config.duration) {\n              this._memoizedDuration = config.duration;\n\n              if (node2.durationProgress > 0) {\n                node2.elapsedTime = config.duration * node2.durationProgress;\n                elapsed = node2.elapsedTime += dt;\n              }\n            }\n\n            p = (config.progress || 0) + elapsed / this._memoizedDuration;\n            p = p > 1 ? 1 : p < 0 ? 0 : p;\n            node2.durationProgress = p;\n          }\n\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node2.lastPosition) / dt;\n          finished = p == 1;\n        } else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e);\n          finished = Math.abs(node2.lastPosition - position) < 0.1;\n          velocity = v0 * e;\n        } else {\n          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;\n          const precision = config.precision || (from == to ? 5e-3 : Math.min(1, Math.abs(to - from) * 1e-3));\n          const restVelocity = config.restVelocity || precision / 10;\n          const bounceFactor = config.clamp ? 0 : config.bounce;\n          const canBounce = !is.und(bounceFactor);\n          const isGrowing = from == to ? node2.v0 > 0 : from < to;\n          let isMoving;\n          let isBouncing = false;\n          const step = 1;\n          const numSteps = Math.ceil(dt / step);\n\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity;\n\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision;\n\n              if (finished) {\n                break;\n              }\n            }\n\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing;\n\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor;\n                position = to;\n              }\n            }\n\n            const springForce = -config.tension * 1e-6 * (position - to);\n            const dampingForce = -config.friction * 1e-3 * velocity;\n            const acceleration = (springForce + dampingForce) / config.mass;\n            velocity = velocity + acceleration * step;\n            position = position + velocity * step;\n          }\n        }\n\n        node2.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this);\n          finished = true;\n        }\n      }\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node2.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node2.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    const node = getAnimated(this);\n\n    if (idle) {\n      const value = getFluidValue(anim.to);\n\n      if (node.setValue(value) || changed) {\n        this._onChange(value);\n      }\n\n      this._stop();\n    } else if (changed) {\n      this._onChange(node.getValue());\n    }\n  }\n\n  set(value) {\n    raf.batchedUpdates(() => {\n      this._stop();\n\n      this._focus(value);\n\n      this._set(value);\n    });\n    return this;\n  }\n\n  pause() {\n    this._update({\n      pause: true\n    });\n  }\n\n  resume() {\n    this._update({\n      pause: false\n    });\n  }\n\n  finish() {\n    if (isAnimating(this)) {\n      const {\n        to,\n        config\n      } = this.animation;\n      raf.batchedUpdates(() => {\n        this._onStart();\n\n        if (!config.decay) {\n          this._set(to, false);\n        }\n\n        this._stop();\n      });\n    }\n\n    return this;\n  }\n\n  update(props) {\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  start(to, arg2) {\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : { ...arg2,\n        to\n      }];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    return Promise.all(queue.map(props => this._update(props))).then(results => getCombinedResult(this, results));\n  }\n\n  stop(cancel) {\n    const {\n      to\n    } = this.animation;\n\n    this._focus(this.get());\n\n    stopAsync(this._state, cancel && this._lastCallId);\n    raf.batchedUpdates(() => this._stop(to, cancel));\n    return this;\n  }\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._start();\n    } else if (event.type == \"priority\") {\n      this.priority = event.priority + 1;\n    }\n  }\n\n  _prepareNode(props) {\n    const key = this.key || \"\";\n    let {\n      to,\n      from\n    } = props;\n    to = is.obj(to) ? to[key] : to;\n\n    if (to == null || isAsyncTo(to)) {\n      to = void 0;\n    }\n\n    from = is.obj(from) ? from[key] : from;\n\n    if (from == null) {\n      from = void 0;\n    }\n\n    const range = {\n      to,\n      from\n    };\n\n    if (!hasAnimated(this)) {\n      if (props.reverse) [to, from] = [from, to];\n      from = getFluidValue(from);\n\n      if (!is.und(from)) {\n        this._set(from);\n      } else if (!getAnimated(this)) {\n        this._set(to);\n      }\n    }\n\n    return range;\n  }\n\n  _update(_ref2, isLoop) {\n    let { ...props\n    } = _ref2;\n    const {\n      key,\n      defaultProps\n    } = this;\n    if (props.default) Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));\n    mergeActiveFn(this, props, \"onProps\");\n    sendEvent(this, \"onProps\", props, this);\n\n    const range = this._prepareNode(props);\n\n    if (Object.isFrozen(this)) {\n      throw Error(\"Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?\");\n    }\n\n    const state = this._state;\n    return scheduleProps(++this._lastCallId, {\n      key,\n      props,\n      defaultProps,\n      state,\n      actions: {\n        pause: () => {\n          if (!isPaused(this)) {\n            setPausedBit(this, true);\n            flushCalls(state.pauseQueue);\n            sendEvent(this, \"onPause\", getFinishedResult(this, checkFinished(this, this.animation.to)), this);\n          }\n        },\n        resume: () => {\n          if (isPaused(this)) {\n            setPausedBit(this, false);\n\n            if (isAnimating(this)) {\n              this._resume();\n            }\n\n            flushCalls(state.resumeQueue);\n            sendEvent(this, \"onResume\", getFinishedResult(this, checkFinished(this, this.animation.to)), this);\n          }\n        },\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n\n  _merge(range, props, resolve) {\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    const hasToProp = !is.und(range.to);\n    const hasFromProp = !is.und(range.from);\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n\n    const {\n      key,\n      defaultProps,\n      animation: anim\n    } = this;\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range;\n\n    if (hasFromProp && !hasToProp && (!props.default || is.und(to))) {\n      to = from;\n    }\n\n    if (props.reverse) [to, from] = [from, to];\n    const hasFromChanged = !isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n\n    from = getFluidValue(from);\n    const hasToChanged = !isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    }\n\n    const hasAsyncTo = isAsyncTo(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config;\n\n    if (hasToProp || hasFromProp) {\n      config.velocity = 0;\n    }\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    }\n\n    let node = getAnimated(this);\n\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n\n    const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);\n    const value = reset ? from : this.get();\n    const goal = computeGoal(to);\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      const nodeType = getAnimatedType(to);\n\n      if (nodeType !== node.constructor) {\n        if (immediate) {\n          node = this._set(goal);\n        } else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`);\n      }\n    }\n\n    const goalType = node.constructor;\n    let started = hasFluidValue(to);\n    let finished = false;\n\n    if (!started) {\n      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\n\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal);\n        started = !finished;\n      }\n\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    }\n\n    if (finished && isAnimating(this)) {\n      if (anim.changed && !reset) {\n        started = true;\n      } else if (!started) {\n        this._stop(prevTo);\n      }\n    }\n\n    if (!hasAsyncTo) {\n      if (started || hasFluidValue(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = hasFluidValue(to) ? null : goalType == AnimatedString ? [1] : toArray(goal);\n      }\n\n      if (anim.immediate != immediate) {\n        anim.immediate = immediate;\n\n        if (!immediate && !reset) {\n          this._set(prevTo);\n        }\n      }\n\n      if (started) {\n        const {\n          onRest\n        } = anim;\n        each(ACTIVE_EVENTS, type => mergeActiveFn(this, props, type));\n        const result = getFinishedResult(this, checkFinished(this, prevTo));\n        flushCalls(this._pendingCalls, result);\n\n        this._pendingCalls.add(resolve);\n\n        if (anim.changed) raf.batchedUpdates(() => {\n          var _a;\n\n          anim.changed = !reset;\n          onRest == null ? void 0 : onRest(result, this);\n\n          if (reset) {\n            callProp(defaultProps.onRest, result);\n          } else {\n            (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);\n          }\n        });\n      }\n    }\n\n    if (reset) {\n      this._set(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } else if (started) {\n      this._start();\n    } else if (isAnimating(this) && !hasToChanged) {\n      this._pendingCalls.add(resolve);\n    } else {\n      resolve(getNoopResult(value));\n    }\n  }\n\n  _focus(value) {\n    const anim = this.animation;\n\n    if (value !== anim.to) {\n      if (getFluidObservers(this)) {\n        this._detach();\n      }\n\n      anim.to = value;\n\n      if (getFluidObservers(this)) {\n        this._attach();\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 0;\n    const {\n      to\n    } = this.animation;\n\n    if (hasFluidValue(to)) {\n      addFluidObserver(to, this);\n\n      if (isFrameValue(to)) {\n        priority = to.priority + 1;\n      }\n    }\n\n    this.priority = priority;\n  }\n\n  _detach() {\n    const {\n      to\n    } = this.animation;\n\n    if (hasFluidValue(to)) {\n      removeFluidObserver(to, this);\n    }\n  }\n\n  _set(arg) {\n    let idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const value = getFluidValue(arg);\n\n    if (!is.und(value)) {\n      const oldNode = getAnimated(this);\n\n      if (!oldNode || !isEqual(value, oldNode.getValue())) {\n        const nodeType = getAnimatedType(value);\n\n        if (!oldNode || oldNode.constructor != nodeType) {\n          setAnimated(this, nodeType.create(value));\n        } else {\n          oldNode.setValue(value);\n        }\n\n        if (oldNode) {\n          raf.batchedUpdates(() => {\n            this._onChange(value, idle);\n          });\n        }\n      }\n    }\n\n    return getAnimated(this);\n  }\n\n  _onStart() {\n    const anim = this.animation;\n\n    if (!anim.changed) {\n      anim.changed = true;\n      sendEvent(this, \"onStart\", getFinishedResult(this, checkFinished(this, anim.to)), this);\n    }\n  }\n\n  _onChange(value, idle) {\n    if (!idle) {\n      this._onStart();\n\n      callProp(this.animation.onChange, value, this);\n    }\n\n    callProp(this.defaultProps.onChange, value, this);\n\n    super._onChange(value, idle);\n  }\n\n  _start() {\n    const anim = this.animation;\n    getAnimated(this).reset(getFluidValue(anim.to));\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n\n    if (!isAnimating(this)) {\n      setActiveBit(this, true);\n\n      if (!isPaused(this)) {\n        this._resume();\n      }\n    }\n  }\n\n  _resume() {\n    if (Globals.skipAnimation) {\n      this.finish();\n    } else {\n      frameLoop.start(this);\n    }\n  }\n\n  _stop(goal, cancel) {\n    if (isAnimating(this)) {\n      setActiveBit(this, false);\n      const anim = this.animation;\n      each(anim.values, node => {\n        node.done = true;\n      });\n\n      if (anim.toValues) {\n        anim.onChange = anim.onPause = anim.onResume = void 0;\n      }\n\n      callFluidObservers(this, {\n        type: \"idle\",\n        parent: this\n      });\n      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));\n      flushCalls(this._pendingCalls, result);\n\n      if (anim.changed) {\n        anim.changed = false;\n        sendEvent(this, \"onRest\", result, this);\n      }\n    }\n  }\n\n}\n\nfunction checkFinished(target, to) {\n  const goal = computeGoal(to);\n  const value = computeGoal(target.get());\n  return isEqual(value, goal);\n}\n\nfunction createLoopUpdate(props) {\n  let loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : props.loop;\n  let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : props.to;\n  let loopRet = callProp(loop);\n\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate({ ...props,\n      loop,\n      default: false,\n      pause: void 0,\n      to: !reverse || isAsyncTo(to) ? to : void 0,\n      from: reset ? props.from : void 0,\n      reset,\n      ...overrides\n    });\n  }\n}\n\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props);\n  const keys = new Set();\n  if (is.obj(to)) findDefined(to, keys);\n  if (is.obj(from)) findDefined(from, keys);\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update);\n  }\n\n  return update;\n}\n\nfunction findDefined(values, keys) {\n  eachProp(values, (value, key) => value != null && keys.add(key));\n}\n\nconst ACTIVE_EVENTS = [\"onStart\", \"onRest\", \"onChange\", \"onPause\", \"onResume\"];\n\nfunction mergeActiveFn(target, props, type) {\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;\n}\n\nfunction sendEvent(target, type) {\n  var _a, _b, _c, _d;\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    args[_key4 - 2] = arguments[_key4];\n  }\n\n  (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);\n  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);\n}\n\nconst BATCHED_EVENTS = [\"onStart\", \"onChange\", \"onRest\"];\nlet nextId$1 = 1;\n\nclass Controller {\n  constructor(props, flush2) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._changed = new Set();\n    this._started = false;\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._events = {\n      onStart: new Map(),\n      onChange: new Map(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush2) {\n      this._flush = flush2;\n    }\n\n    if (props) {\n      this.start({\n        default: true,\n        ...props\n      });\n    }\n  }\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => spring.idle);\n  }\n\n  get item() {\n    return this._item;\n  }\n\n  set item(item) {\n    this._item = item;\n  }\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n\n  set(values) {\n    for (const key in values) {\n      const value = values[key];\n\n      if (!is.und(value)) {\n        this.springs[key].set(value);\n      }\n    }\n  }\n\n  update(props) {\n    if (props) {\n      this.queue.push(createUpdate(props));\n    }\n\n    return this;\n  }\n\n  start(props) {\n    let {\n      queue\n    } = this;\n\n    if (props) {\n      queue = toArray(props).map(createUpdate);\n    } else {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n\n  stop(arg, keys) {\n    if (arg !== !!arg) {\n      keys = arg;\n    }\n\n    if (keys) {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].stop(!!arg));\n    } else {\n      stopAsync(this._state, this._lastAsyncId);\n      this.each(spring => spring.stop(!!arg));\n    }\n\n    return this;\n  }\n\n  pause(keys) {\n    if (is.und(keys)) {\n      this.start({\n        pause: true\n      });\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].pause());\n    }\n\n    return this;\n  }\n\n  resume(keys) {\n    if (is.und(keys)) {\n      this.start({\n        pause: false\n      });\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].resume());\n    }\n\n    return this;\n  }\n\n  each(iterator) {\n    eachProp(this.springs, iterator);\n  }\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const active = this._active.size > 0;\n    const changed = this._changed.size > 0;\n\n    if (active && !this._started || changed && !this._started) {\n      this._started = true;\n      flush(onStart, _ref3 => {\n        let [onStart2, result] = _ref3;\n        result.value = this.get();\n        onStart2(result, this, this._item);\n      });\n    }\n\n    const idle = !active && this._started;\n    const values = changed || idle && onRest.size ? this.get() : null;\n\n    if (changed && onChange.size) {\n      flush(onChange, _ref4 => {\n        let [onChange2, result] = _ref4;\n        result.value = values;\n        onChange2(result, this, this._item);\n      });\n    }\n\n    if (idle) {\n      this._started = false;\n      flush(onRest, _ref5 => {\n        let [onRest2, result] = _ref5;\n        result.value = values;\n        onRest2(result, this, this._item);\n      });\n    }\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._changed.add(event.parent);\n\n      if (!event.idle) {\n        this._active.add(event.parent);\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else return;\n\n    raf.onFrame(this._onFrame);\n  }\n\n}\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\n\nasync function flushUpdate(ctrl, props, isLoop) {\n  const {\n    keys,\n    to,\n    from,\n    loop,\n    onRest,\n    onResolve\n  } = props;\n  const defaults = is.obj(props.default) && props.default;\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  if (to === false) props.to = null;\n  if (from === false) props.from = null;\n  const asyncTo = is.arr(to) || is.fun(to) ? to : void 0;\n\n  if (asyncTo) {\n    props.to = void 0;\n    props.onRest = void 0;\n\n    if (defaults) {\n      defaults.onRest = void 0;\n    }\n  } else {\n    each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n\n      if (is.fun(handler)) {\n        const queue = ctrl[\"_events\"][key];\n\n        props[key] = _ref6 => {\n          let {\n            finished,\n            cancelled\n          } = _ref6;\n          const result2 = queue.get(handler);\n\n          if (result2) {\n            if (!finished) result2.finished = false;\n            if (cancelled) result2.cancelled = true;\n          } else {\n            queue.set(handler, {\n              value: null,\n              finished: finished || false,\n              cancelled: cancelled || false\n            });\n          }\n        };\n\n        if (defaults) {\n          defaults[key] = props[key];\n        }\n      }\n    });\n  }\n\n  const state = ctrl[\"_state\"];\n\n  if (props.pause === !state.paused) {\n    state.paused = props.pause;\n    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);\n  } else if (state.paused) {\n    props.pause = true;\n  }\n\n  const promises = (keys || Object.keys(ctrl.springs)).map(key => ctrl.springs[key].start(props));\n  const cancel = props.cancel === true || getDefaultProp(props, \"cancel\") === true;\n\n  if (asyncTo || cancel && state.asyncId) {\n    promises.push(scheduleProps(++ctrl[\"_lastAsyncId\"], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n\n        start(props2, resolve) {\n          if (cancel) {\n            stopAsync(state, ctrl[\"_lastAsyncId\"]);\n            resolve(getCancelledResult(ctrl));\n          } else {\n            props2.onRest = onRest;\n            resolve(runAsync(asyncTo, props2, state, ctrl));\n          }\n        }\n\n      }\n    }));\n  }\n\n  if (state.paused) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n\n  const result = getCombinedResult(ctrl, await Promise.all(promises));\n\n  if (loop && result.finished && !(isLoop && result.noop)) {\n    const nextProps = createLoopUpdate(props, loop, to);\n\n    if (nextProps) {\n      prepareKeys(ctrl, [nextProps]);\n      return flushUpdate(ctrl, nextProps, true);\n    }\n  }\n\n  if (onResolve) {\n    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));\n  }\n\n  return result;\n}\n\nfunction getSprings(ctrl, props) {\n  const springs = { ...ctrl.springs\n  };\n\n  if (props) {\n    each(toArray(props), props2 => {\n      if (is.und(props2.keys)) {\n        props2 = createUpdate(props2);\n      }\n\n      if (!is.obj(props2.to)) {\n        props2 = { ...props2,\n          to: void 0\n        };\n      }\n\n      prepareSprings(springs, props2, key => {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n\nfunction setSprings(ctrl, springs) {\n  eachProp(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      addFluidObserver(spring, ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    addFluidObserver(spring, observer);\n  }\n\n  return spring;\n}\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring[\"_prepareNode\"](props);\n    });\n  }\n}\n\nfunction prepareKeys(ctrl, queue) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\nconst SpringContext = _ref7 => {\n  let {\n    children,\n    ...props\n  } = _ref7;\n  const inherited = useContext(ctx);\n  const pause = props.pause || !!inherited.pause,\n        immediate = props.immediate || !!inherited.immediate;\n  props = useMemoOne(() => ({\n    pause,\n    immediate\n  }), [pause, immediate]);\n  const {\n    Provider\n  } = ctx;\n  return /* @__PURE__ */createElement(Provider, {\n    value: props\n  }, children);\n};\n\nconst ctx = makeContext(SpringContext, {});\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n\nfunction makeContext(target, init) {\n  Object.assign(target, createContext(init));\n  target.Provider._context = target;\n  target.Consumer._context = target;\n  return target;\n}\n\nclass SpringRef extends Function {\n  constructor() {\n    super(\"return arguments.callee._call.apply(arguments.callee, arguments)\");\n    this.current = [];\n  }\n\n  _call(props) {\n    deprecateDirectCall();\n    this.start(props);\n  }\n\n  set(values) {\n    each(this.current, ctrl => ctrl.set(values));\n  }\n\n  start(props) {\n    const results = [];\n    each(this.current, (ctrl, i) => {\n      if (is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update = this._getProps(props, ctrl, i);\n\n        if (update) {\n          results.push(ctrl.start(update));\n        }\n      }\n    });\n    return results;\n  }\n\n  update(props) {\n    each(this.current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));\n    return this;\n  }\n\n  add(ctrl) {\n    if (!this.current.includes(ctrl)) {\n      this.current.push(ctrl);\n    }\n  }\n\n  delete(ctrl) {\n    const i = this.current.indexOf(ctrl);\n    if (~i) this.current.splice(i, 1);\n  }\n\n  _getProps(arg, ctrl, index) {\n    return is.fun(arg) ? arg(index, ctrl) : arg;\n  }\n\n}\n\neach([\"stop\", \"pause\", \"resume\"], key => {\n  SpringRef.prototype[key] = function () {\n    each(this.current, ctrl => ctrl[key](...arguments));\n    return this;\n  };\n});\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  const ref = useMemo(() => propsFn || arguments.length == 3 ? new SpringRef() : void 0, []);\n  const layoutId = useRef(0);\n  const forceUpdate = useForceUpdate();\n  const state = useMemo(() => ({\n    ctrls: [],\n    queue: [],\n\n    flush(ctrl, updates2) {\n      const springs2 = getSprings(ctrl, updates2);\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise(resolve => {\n        setSprings(ctrl, springs2);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates2));\n        });\n        forceUpdate();\n      });\n    }\n\n  }), []);\n  const ctrls = [...state.ctrls];\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  const oldCtrls = ctrls.slice(length, prevLength);\n  useMemo(() => {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]);\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        updates[i] = declareUpdate(update);\n      }\n    }\n  }\n\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = useContext(SpringContext);\n  const prevContext = usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(() => {\n    layoutId.current++;\n    state.ctrls = ctrls;\n    const {\n      queue\n    } = state;\n\n    if (queue.length) {\n      state.queue = [];\n      each(queue, cb => cb());\n    }\n\n    each(oldCtrls, ctrl => {\n      detachRefs(ctrl, ref);\n      ctrl.stop(true);\n    });\n    each(ctrls, (ctrl, i) => {\n      const values2 = springs[i];\n      setSprings(ctrl, values2);\n      ref == null ? void 0 : ref.add(ctrl);\n\n      if (hasContext) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      const update = updates[i];\n\n      if (update) {\n        replaceRef(ctrl, update.ref);\n\n        if (ctrl.ref) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  });\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.stop(true));\n  });\n  const values = springs.map(x => ({ ...x\n  }));\n  return ref ? [values, ref] : values;\n}\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, ref] : values;\n}\n\nconst initSpringRef = () => new SpringRef();\n\nconst useSpringRef = () => useState(initSpringRef)[0];\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  let reverse = true;\n  const result = useSprings(length, (i, ctrl) => {\n    const props = propsFn ? propsFn(i, ctrl) : propsArg;\n    reverse = reverse && props.reverse;\n    return props;\n  }, deps || [{}]);\n  const ref = result[1];\n  useLayoutEffect(() => {\n    each(ref.current, (ctrl, i) => {\n      const parent = ref.current[i + (reverse ? 1 : -1)];\n      if (parent) ctrl.start({\n        to: parent.springs\n      });\n    });\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    ref[\"_getProps\"] = (propsArg2, ctrl, i) => {\n      const props = is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;\n\n      if (props) {\n        const parent = ref.current[i + (props.reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      }\n    };\n\n    return result;\n  }\n\n  return result[0];\n}\n\nconst MOUNT = \"mount\";\nconst ENTER = \"enter\";\nconst UPDATE = \"update\";\nconst LEAVE = \"leave\";\n\nfunction useTransition(data, props, deps) {\n  const {\n    reset,\n    sort,\n    trail = 0,\n    expires = true,\n    onDestroyed\n  } = props;\n  const ref = useMemo(() => arguments.length == 3 ? new SpringRef() : void 0, []);\n  const items = toArray(data);\n  const transitions = [];\n  const usedTransitions = useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  });\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    }\n\n    detachRefs(t.ctrl, ref);\n    t.ctrl.stop(true);\n  }));\n  const keys = getKeys(items, props, prevTransitions);\n  const expired = reset && usedTransitions.current || [];\n  useLayoutEffect(() => each(expired, _ref8 => {\n    let {\n      ctrl,\n      item,\n      key\n    } = _ref8;\n    detachRefs(ctrl, ref);\n    callProp(onDestroyed, item, key);\n  }));\n  const reused = [];\n  if (prevTransitions) each(prevTransitions, (t, i) => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n      expired.push(t);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  });\n  each(items, (item, i) => {\n    if (!transitions[i]) {\n      transitions[i] = {\n        key: keys[i],\n        item,\n        phase: MOUNT,\n        ctrl: new Controller()\n      };\n      transitions[i].ctrl.item = item;\n    }\n  });\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = { ...t,\n          item: items[keyIndex]\n        };\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  }\n\n  let delay = -trail;\n  const forceUpdate = useForceUpdate();\n  const defaultProps = getDefaultProps(props);\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    let to;\n    let phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    }\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      const config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i, phase);\n    }\n\n    const payload = { ...defaultProps,\n      delay: delay += trail,\n      reset: false,\n      ...to\n    };\n\n    if (phase == ENTER && is.und(payload.from)) {\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    const {\n      onResolve\n    } = payload;\n\n    payload.onResolve = result => {\n      callProp(onResolve, result);\n      const transitions2 = usedTransitions.current;\n      const t2 = transitions2.find(t3 => t3.key === key);\n      if (!t2) return;\n\n      if (result.cancelled && t2.phase != UPDATE) {\n        return;\n      }\n\n      if (t2.ctrl.idle) {\n        const idle = transitions2.every(t3 => t3.ctrl.idle);\n\n        if (t2.phase == LEAVE) {\n          const expiry = callProp(expires, t2.item);\n\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t2.expired = true;\n\n            if (!idle && expiryMs > 0) {\n              if (expiryMs <= 2147483647) t2.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        }\n\n        if (idle && transitions2.some(t3 => t3.expired)) {\n          forceUpdate();\n        }\n      }\n    };\n\n    const springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase,\n      springs,\n      payload\n    });\n  });\n  const context = useContext(SpringContext);\n  const prevContext = usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(() => {\n    if (hasContext) each(transitions, t => {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  useLayoutEffect(() => {\n    each(changes, (_ref9, t) => {\n      let {\n        phase,\n        springs,\n        payload\n      } = _ref9;\n      const {\n        ctrl\n      } = t;\n      t.phase = phase;\n      ref == null ? void 0 : ref.add(ctrl);\n      replaceRef(ctrl, payload.ref);\n      setSprings(ctrl, springs);\n\n      if (hasContext && phase == ENTER) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      ctrl[ctrl.ref ? \"update\" : \"start\"](payload);\n    });\n  }, reset ? void 0 : deps);\n\n  const renderTransitions = render => /* @__PURE__ */createElement(Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render({ ...springs\n    }, t.item, t, i);\n    return elem && elem.type ? /* @__PURE__ */createElement(elem.type, { ...elem.props,\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    }) : elem;\n  }));\n\n  return ref ? [renderTransitions, ref] : renderTransitions;\n}\n\nlet nextKey = 1;\n\nfunction getKeys(items, _ref10, prevTransitions) {\n  let {\n    key,\n    keys = key\n  } = _ref10;\n\n  if (keys === null) {\n    const reused = new Set();\n    return items.map(item => {\n      const t = prevTransitions && prevTransitions.find(t2 => t2.item === item && t2.phase !== LEAVE && !reused.has(t2));\n\n      if (t) {\n        reused.add(t);\n        return t.key;\n      }\n\n      return nextKey++;\n    });\n  }\n\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction Spring(_ref11) {\n  let {\n    children,\n    ...props\n  } = _ref11;\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref12) {\n  let {\n    items,\n    children,\n    ...props\n  } = _ref12;\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref13) {\n  let {\n    items,\n    children,\n    ...props\n  } = _ref13;\n  return useTransition(items, props)(children);\n}\n\nclass Interpolation extends FrameValue {\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.idle = true;\n    this._active = new Set();\n    this.calc = createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = getAnimatedType(value);\n    setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n\n    if (!this.idle && checkIdle(this._active)) {\n      becomeIdle(this);\n    }\n  }\n\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));\n    return this.calc(...inputs);\n  }\n\n  _start() {\n    if (this.idle && !checkIdle(this._active)) {\n      this.idle = false;\n      each(getPayload(this), node => {\n        node.done = false;\n      });\n\n      if (Globals.skipAnimation) {\n        raf.batchedUpdates(() => this.advance());\n        becomeIdle(this);\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (hasFluidValue(source)) {\n        addFluidObserver(source, this);\n      }\n\n      if (isFrameValue(source)) {\n        if (!source.idle) {\n          this._active.add(source);\n        }\n\n        priority = Math.max(priority, source.priority + 1);\n      }\n    });\n    this.priority = priority;\n\n    this._start();\n  }\n\n  _detach() {\n    each(toArray(this.source), source => {\n      if (hasFluidValue(source)) {\n        removeFluidObserver(source, this);\n      }\n    });\n\n    this._active.clear();\n\n    becomeIdle(this);\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      if (event.idle) {\n        this.advance();\n      } else {\n        this._active.add(event.parent);\n\n        this._start();\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else if (event.type == \"priority\") {\n      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);\n    }\n  }\n\n}\n\nfunction isIdle(source) {\n  return source.idle !== false;\n}\n\nfunction checkIdle(active) {\n  return !active.size || Array.from(active).every(isIdle);\n}\n\nfunction becomeIdle(self) {\n  if (!self.idle) {\n    self.idle = true;\n    each(getPayload(self), node => {\n      node.done = true;\n    });\n    callFluidObservers(self, {\n      type: \"idle\",\n      parent: self\n    });\n  }\n}\n\nconst to = function (source) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  return new Interpolation(source, args);\n};\n\nconst interpolate = function (source) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    args[_key6 - 1] = arguments[_key6];\n  }\n\n  return deprecateInterpolate(), new Interpolation(source, args);\n};\n\nGlobals.assign({\n  createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args)\n});\nconst update = frameLoop.advance;\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringRef, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSpringRef, useSprings, useTrail, useTransition };","map":{"version":3,"mappings":"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","names":["value","args","is","fun","key","toArray","includes","obj","prop","props","default","transform","DEFAULT_PROPS","keys","Object","und","defaults","config","from","to","ref","loop","reset","pause","cancel","reverse","immediate","delay","onProps","onStart","onChange","onPause","onResume","onRest","onResolve","items","trail","sort","expires","initial","enter","update","leave","children","onDestroyed","callId","parentId","eachProp","RESERVED_PROPS","forward","count","getForwardProps","out","val","getFluidValue","arr","map","computeGoal","isAnimatedString","G","createStringInterpolator","range","output","delete","ctrl","add","refs","timeFrame","useLayoutEffect","timeSteps","each","current","controllers","length","i","isNaN","prevDelay","queue","callProp","memoizedDelayProp","start","Promise","resolve","q","p","then","queues","push","tension","friction","gentle","wobbly","stiff","slow","molasses","linear","t","configs","mass","damping","easing","clamp","constructor","assign","defaultConfig","sanitizeConfig","newConfig","frequency","Math","pow","PI","decay","duration","isTensionConfig","emptyArray","AnimationConfig2","defaultProps","state","actions","matchProp","paused","resumeQueue","resume","timeouts","timeout","time","raf","now","setTimeout","pauseQueue","cancelId","reject","err","getCombinedResult","results","some","result","cancelled","getCancelledResult","target","get","every","noop","getNoopResult","getFinishedResult","finished","asyncTo","promise","prevTo","prevPromise","asyncId","getDefaultProps","bail","bailSignal","bailResult","BailSignal","SkipAniamtionSignal","skipAnimation","stopAsync","skipAnimationSignal","bailIfEnded","arg1","arg2","props2","result2","animating","animate","stop","bind","all","preventBail","bailPromise","batchedUpdates","item","flush","clear","Error","isFrameValue","FrameValue","FluidValue","nextId","_priority","priority","_onPriorityChange","getAnimated","node","getValue","interpolate","deprecateInterpolate","toJSON","observerAdded","_attach","observerRemoved","_detach","_onChange","idle","callFluidObservers","type","parent","frameLoop","$P","Symbol","for","HAS_ANIMATED","IS_ANIMATING","IS_PAUSED","active","FrameValue2","Animation2","Set","_state","isPaused","animation","AnimatedValue","lastVelocity","getPayload","node2","hasAnimated","isAnimating","advance","toValues","anim","payload","hasFluidValue","values","forEach","done","AnimatedString","lastPosition","position","elapsedTime","dt","fromValues","v0","velocity","_memoizedDuration","durationProgress","elapsed","progress","exp","e","abs","precision","min","restVelocity","bounce","bounceFactor","ceil","step","n","numSteps","isMoving","canBounce","isBouncing","isGrowing","dampingForce","acceleration","Number","console","warn","setValue","round","changed","_stop","set","_focus","_set","_update","finish","_onStart","_lastCallId","eventObserved","event","_start","_prepareNode","isAsyncTo","test","resolveProp","mergeActiveFn","sendEvent","isFrozen","scheduleProps2","setPausedBit","flushCalls","checkFinished","_resume","_merge","createLoopUpdate","nextProps","hasToProp","hasFromProp","_lastToId","prevFrom","isEqual","hasFromChanged","hasToChanged","hasAsyncTo","mergeConfig","num","goal","isAnimatable","getAnimatedType","nodeType","name","started","hasValueChanged","goalType","ACTIVE_EVENTS","_pendingCalls","runAsync2","getFluidObservers","addFluidObserver","removeFluidObserver","arg","oldNode","setAnimated","create","setActiveBit","loopRet","inferTo","overrides","createUpdate","findDefined","size","Array","getDefaultProp","BATCHED_EVENTS","Map","_onFrame","flush2","_flush","springs","spring","_item","prepareKeys","flushUpdateQueue","_lastAsyncId","iterator","_events","_active","_changed","_started","onStart2","onChange2","onRest2","onFrame","flushUpdate","handler","promises","prepareSprings","createSpring","SpringValue2","observer","SpringContext","useContext","ctx","inherited","useMemoOne","Provider","makeContext","Consumer","React.createContext","init","_context","Function","_call","deprecateDirectCall","_getProps","indexOf","splice","index","SpringRef","prototype","arguments","propsFn","deps","useMemo","SpringRef2","useRef","useForceUpdate","ctrls","getSprings","updates2","layoutId","springs2","canFlushSync","setSprings","forceUpdate","usePrev","slice","prevLength","declareUpdates","startIndex","endIndex","Controller2","updates","declareUpdate","SpringContext2","context","prevContext","hasProps","cb","oldCtrls","detachRefs","values2","hasContext","replaceRef","useOnce","x","useSprings2","isFn","initSpringRef","useState","propsArg","propsArg2","MOUNT","data","usedTransitions","transitions","expired","clearTimeout","expirationId","getKeys","prevTransitions","reused","phase","prevIndex","keyIndex","a","b","prevPhase","ENTER","LEAVE","isLeave","UPDATE","transitions2","find","t3","t2","expiry","expiryMs","changes","render","elem","str","id","renderTransitions","has","nextKey","useSpring2","useTrail2","trails","useTransition","source","calc","createInterpolator","_get","oldValue","checkIdle","becomeIdle","inputs","max","reduce","highest","isIdle","self","Interpolation2","Globals"],"sources":["/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/helpers.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/hooks/useChain.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/constants.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/AnimationConfig.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/Animation.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/scheduleProps.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/AnimationResult.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/runAsync.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/FrameValue.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/SpringPhase.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/SpringValue.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/Controller.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/SpringContext.tsx","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/SpringRef.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/hooks/useSprings.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/hooks/useSpring.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/hooks/useSpringRef.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/hooks/useTrail.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/TransitionPhase.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/hooks/useTransition.tsx","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/components/Spring.tsx","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/components/Trail.tsx","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/components/Transition.tsx","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/Interpolation.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/interpolate.ts","/Users/sabourin/Desktop/projet_perso/LotOf_ReactProject/React-anim/node_modules/@react-spring/core/src/globals.ts"],"sourcesContent":["import {\n  is,\n  toArray,\n  eachProp,\n  getFluidValue,\n  isAnimatedString,\n  FluidValue,\n  Globals as G,\n} from '@react-spring/shared'\nimport { AnyFn, OneOrMore, Lookup } from '@react-spring/types'\nimport { ReservedProps, ForwardProps, InferTo } from './types'\nimport type { Controller } from './Controller'\nimport type { SpringRef } from './SpringRef'\n\nexport function callProp<T>(\n  value: T,\n  ...args: T extends AnyFn ? Parameters<T> : unknown[]\n): T extends AnyFn<any, infer U> ? U : T {\n  return is.fun(value) ? value(...args) : value\n}\n\n/** Try to coerce the given value into a boolean using the given key */\nexport const matchProp = (\n  value: boolean | OneOrMore<string> | ((key: any) => boolean) | undefined,\n  key: string | undefined\n) =>\n  value === true ||\n  !!(\n    key &&\n    value &&\n    (is.fun(value) ? value(key) : toArray(value).includes(key))\n  )\n\nexport const resolveProp = <T>(\n  prop: T | Lookup<T> | undefined,\n  key: string | undefined\n) => (is.obj(prop) ? key && (prop as any)[key] : prop)\n\nexport const concatFn = <T extends AnyFn>(first: T | undefined, last: T) =>\n  first ? (...args: Parameters<T>) => (first(...args), last(...args)) : last\n\n/** Returns `true` if the given prop is having its default value set. */\nexport const hasDefaultProp = <T extends Lookup>(props: T, key: keyof T) =>\n  !is.und(getDefaultProp(props, key))\n\n/** Get the default value being set for the given `key` */\nexport const getDefaultProp = <T extends Lookup, P extends keyof T>(\n  props: T,\n  key: P\n): T[P] =>\n  props.default === true\n    ? props[key]\n    : props.default\n    ? props.default[key]\n    : undefined\n\nconst noopTransform = (value: any) => value\n\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\nexport const getDefaultProps = <T extends Lookup>(\n  props: Lookup,\n  transform: (value: any, key: string) => any = noopTransform\n): T => {\n  let keys: readonly string[] = DEFAULT_PROPS\n  if (props.default && props.default !== true) {\n    props = props.default\n    keys = Object.keys(props)\n  }\n  const defaults: any = {}\n  for (const key of keys) {\n    const value = transform(props[key], key)\n    if (!is.und(value)) {\n      defaults[key] = value\n    }\n  }\n  return defaults\n}\n\n/**\n * These props are implicitly used as defaults when defined in a\n * declarative update (eg: render-based) or any update with `default: true`.\n *\n * Use `default: {}` or `default: false` to opt-out of these implicit defaults\n * for any given update.\n *\n * Note: These are not the only props with default values. For example, the\n * `pause`, `cancel`, and `immediate` props. But those must be updated with\n * the object syntax (eg: `default: { immediate: true }`).\n */\nexport const DEFAULT_PROPS = [\n  'config',\n  'onProps',\n  'onStart',\n  'onChange',\n  'onPause',\n  'onResume',\n  'onRest',\n] as const\n\nconst RESERVED_PROPS: {\n  [key: string]: 1 | undefined\n} = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1,\n}\n\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\nfunction getForwardProps<Props extends ReservedProps>(\n  props: Props\n): ForwardProps<Props> | undefined {\n  const forward: any = {}\n\n  let count = 0\n  eachProp(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value\n      count++\n    }\n  })\n\n  if (count) {\n    return forward\n  }\n}\n\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\nexport function inferTo<T extends object>(props: T): InferTo<T> {\n  const to = getForwardProps(props)\n  if (to) {\n    const out: any = { to }\n    eachProp(props, (val, key) => key in to || (out[key] = val))\n    return out\n  }\n  return { ...props } as any\n}\n\n// Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\nexport function computeGoal<T>(value: T | FluidValue<T>): T {\n  value = getFluidValue(value)\n  return is.arr(value)\n    ? value.map(computeGoal)\n    : isAnimatedString(value)\n    ? (G.createStringInterpolator({\n        range: [0, 1],\n        output: [value, value] as any,\n      })(1) as any)\n    : value\n}\n\nexport function hasProps(props: object) {\n  for (const _ in props) return true\n  return false\n}\n\nexport function isAsyncTo(to: any) {\n  return is.fun(to) || (is.arr(to) && is.obj(to[0]))\n}\n\n/** Detach `ctrl` from `ctrl.ref` and (optionally) the given `ref` */\nexport function detachRefs(ctrl: Controller, ref?: SpringRef) {\n  ctrl.ref?.delete(ctrl)\n  ref?.delete(ctrl)\n}\n\n/** Replace `ctrl.ref` with the given `ref` (if defined) */\nexport function replaceRef(ctrl: Controller, ref?: SpringRef) {\n  if (ref && ctrl.ref !== ref) {\n    ctrl.ref?.delete(ctrl)\n    ref.add(ctrl)\n    ctrl.ref = ref\n  }\n}\n","import { each, useLayoutEffect } from '@react-spring/shared'\nimport { SpringRef } from '../SpringRef'\nimport { callProp } from '../helpers'\n\nexport function useChain(\n  refs: ReadonlyArray<SpringRef>,\n  timeSteps?: number[],\n  timeFrame = 1000\n) {\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0\n      each(refs, (ref, i) => {\n        const controllers = ref.current\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]\n\n          // Use the previous delay if none exists.\n          if (isNaN(delay)) delay = prevDelay\n          else prevDelay = delay\n\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              // memoizing stops recursion #1367\n              const memoizedDelayProp = props.delay\n              props.delay = key => delay + callProp(memoizedDelayProp || 0, key)\n            })\n            ctrl.start()\n          })\n        }\n      })\n    } else {\n      let p: Promise<any> = Promise.resolve()\n      each(refs, ref => {\n        const controllers = ref.current\n        if (controllers.length) {\n          // Take the queue of each controller\n          const queues = controllers.map(ctrl => {\n            const q = ctrl.queue\n            ctrl.queue = []\n            return q\n          })\n\n          // Apply the queue when the previous ref stops animating\n          p = p.then(() => {\n            each(controllers, (ctrl, i) =>\n              each(queues[i] || [], update => ctrl.queue.push(update))\n            )\n            return ref.start()\n          })\n        }\n      })\n    }\n  })\n}\n","// The `mass` prop defaults to 1\nexport const config = {\n  default: { tension: 170, friction: 26 },\n  gentle: { tension: 120, friction: 14 },\n  wobbly: { tension: 180, friction: 12 },\n  stiff: { tension: 210, friction: 20 },\n  slow: { tension: 280, friction: 60 },\n  molasses: { tension: 280, friction: 120 },\n} as const\n","import { is } from '@react-spring/shared'\nimport { config as configs } from './constants'\n\nconst linear = (t: number) => t\nconst defaults: any = {\n  ...configs.default,\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false,\n}\n\nexport class AnimationConfig {\n  /**\n   * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n   *\n   * When tension is zero, no animation occurs.\n   */\n  tension!: number\n\n  /**\n   * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n   *\n   * When `speed` is defined, this value should be between 0 and 1.\n   *\n   * Higher friction means the spring will slow down faster.\n   */\n  friction!: number\n\n  /**\n   * The natural frequency (in seconds), which dictates the number of bounces\n   * per second when no damping exists.\n   *\n   * When defined, `tension` is derived from this, and `friction` is derived\n   * from `tension` and `damping`.\n   */\n  frequency?: number\n\n  /**\n   * The damping ratio, which dictates how the spring slows down.\n   *\n   * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n   * Between `0` and `1` is for you to explore.\n   *\n   * Only works when `frequency` is defined.\n   *\n   * Defaults to 1\n   */\n  damping!: number\n\n  /**\n   * Higher mass means more friction is required to slow down.\n   *\n   * Defaults to 1, which works fine most of the time.\n   */\n  mass!: number\n\n  /**\n   * The initial velocity of one or more values.\n   */\n  velocity: number | number[] = 0\n\n  /**\n   * The smallest velocity before the animation is considered \"not moving\".\n   *\n   * When undefined, `precision` is used instead.\n   */\n  restVelocity?: number\n\n  /**\n   * The smallest distance from a value before that distance is essentially zero.\n   *\n   * This helps in deciding when a spring is \"at rest\". The spring must be within\n   * this distance from its final value, and its velocity must be lower than this\n   * value too (unless `restVelocity` is defined).\n   */\n  precision?: number\n\n  /**\n   * For `duration` animations only. Note: The `duration` is not affected\n   * by this property.\n   *\n   * Defaults to `0`, which means \"start from the beginning\".\n   *\n   * Setting to `1+` makes an immediate animation.\n   *\n   * Setting to `0.5` means \"start from the middle of the easing function\".\n   *\n   * Any number `>= 0` and `<= 1` makes sense here.\n   */\n  progress?: number\n\n  /**\n   * Animation length in number of milliseconds.\n   */\n  duration?: number\n\n  /**\n   * The animation curve. Only used when `duration` is defined.\n   *\n   * Defaults to quadratic ease-in-out.\n   */\n  easing!: (t: number) => number\n\n  /**\n   * Avoid overshooting by ending abruptly at the goal value.\n   */\n  clamp!: boolean\n\n  /**\n   * When above zero, the spring will bounce instead of overshooting when\n   * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n   * whenever its current value equals or exceeds its goal. For example,\n   * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n   * in addition to any friction.\n   */\n  bounce?: number\n\n  /**\n   * \"Decay animations\" decelerate without an explicit goal value.\n   * Useful for scrolling animations.\n   *\n   * Use `true` for the default exponential decay factor (`0.998`).\n   *\n   * When a `number` between `0` and `1` is given, a lower number makes the\n   * animation slow down faster. And setting to `1` would make an unending\n   * animation.\n   */\n  decay?: boolean | number\n\n  /**\n   * While animating, round to the nearest multiple of this number.\n   * The `from` and `to` values are never rounded, as well as any value\n   * passed to the `set` method of an animated value.\n   */\n  round?: number\n\n  constructor() {\n    Object.assign(this, defaults)\n  }\n}\n\nexport function mergeConfig(\n  config: AnimationConfig,\n  newConfig: Partial<AnimationConfig>,\n  defaultConfig?: Partial<AnimationConfig>\n): typeof config\n\nexport function mergeConfig(\n  config: any,\n  newConfig: object,\n  defaultConfig?: object\n) {\n  if (defaultConfig) {\n    defaultConfig = { ...defaultConfig }\n    sanitizeConfig(defaultConfig, newConfig)\n    newConfig = { ...defaultConfig, ...newConfig }\n  }\n\n  sanitizeConfig(config, newConfig)\n  Object.assign(config, newConfig)\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key]\n    }\n  }\n\n  let { mass, frequency, damping } = config\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01\n    if (damping < 0) damping = 0\n    config.tension = Math.pow((2 * Math.PI) / frequency, 2) * mass\n    config.friction = (4 * Math.PI * damping * mass) / frequency\n  }\n\n  return config\n}\n\n// Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\nfunction sanitizeConfig(\n  config: Partial<AnimationConfig>,\n  props: Partial<AnimationConfig>\n) {\n  if (!is.und(props.decay)) {\n    config.duration = undefined\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction)\n    if (\n      isTensionConfig ||\n      !is.und(props.frequency) ||\n      !is.und(props.damping) ||\n      !is.und(props.mass)\n    ) {\n      config.duration = undefined\n      config.decay = undefined\n    }\n    if (isTensionConfig) {\n      config.frequency = undefined\n    }\n  }\n}\n","import { AnimatedValue } from '@react-spring/animated'\nimport { FluidValue } from '@react-spring/shared'\nimport { AnimationConfig } from './AnimationConfig'\nimport { PickEventFns } from './types/internal'\nimport { SpringProps } from './types'\n\nconst emptyArray: readonly any[] = []\n\n/** An animation being executed by the frameloop */\nexport class Animation<T = any> {\n  changed = false\n  values: readonly AnimatedValue[] = emptyArray\n  toValues: readonly number[] | null = null\n  fromValues: readonly number[] = emptyArray\n\n  to!: T | FluidValue<T>\n  from!: T | FluidValue<T>\n  config = new AnimationConfig()\n  immediate = false\n}\n\nexport interface Animation<T> extends PickEventFns<SpringProps<T>> {}\n","import { Timeout, is, raf } from '@react-spring/shared'\nimport { matchProp, callProp } from './helpers'\nimport { AsyncResult, MatchProp } from './types'\nimport { RunAsyncState, RunAsyncProps } from './runAsync'\nimport {\n  AnimationResolver,\n  AnimationTarget,\n  InferProps,\n  InferState,\n} from './types/internal'\n\n// The `scheduleProps` function only handles these defaults.\ntype DefaultProps<T> = { cancel?: MatchProp<T>; pause?: MatchProp<T> }\n\ninterface ScheduledProps<T extends AnimationTarget> {\n  key?: string\n  props: InferProps<T>\n  defaultProps?: DefaultProps<InferState<T>>\n  state: RunAsyncState<T>\n  actions: {\n    pause: () => void\n    resume: () => void\n    start: (props: RunAsyncProps<T>, resolve: AnimationResolver<T>) => void\n  }\n}\n\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\nexport function scheduleProps<T extends AnimationTarget>(\n  callId: number,\n  { key, props, defaultProps, state, actions }: ScheduledProps<T>\n): AsyncResult<T> {\n  return new Promise((resolve, reject) => {\n    let delay: number\n    let timeout: Timeout\n\n    let cancel = matchProp(props.cancel ?? defaultProps?.cancel, key)\n    if (cancel) {\n      onStart()\n    } else {\n      // The `pause` prop updates the paused flag.\n      if (!is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key)\n      }\n      // The default `pause` takes precedence when true,\n      // which allows `SpringContext` to work as expected.\n      let pause = defaultProps?.pause\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key)\n      }\n\n      delay = callProp(props.delay || 0, key)\n      if (pause) {\n        state.resumeQueue.add(onResume)\n        actions.pause()\n      } else {\n        actions.resume()\n        onResume()\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume)\n      state.timeouts.delete(timeout)\n      timeout.cancel()\n      // Cache the remaining delay.\n      delay = timeout.time - raf.now()\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        timeout = raf.setTimeout(onStart, delay)\n        state.pauseQueue.add(onPause)\n        state.timeouts.add(timeout)\n      } else {\n        onStart()\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause)\n      state.timeouts.delete(timeout)\n\n      // Maybe cancelled during its delay.\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true\n      }\n\n      try {\n        actions.start({ ...props, callId, cancel }, resolve)\n      } catch (err) {\n        reject(err)\n      }\n    }\n  })\n}\n","import { AnimationResult } from './types'\nimport { Readable } from './types/internal'\n\n/** @internal */\nexport const getCombinedResult = <T extends Readable>(\n  target: T,\n  results: AnimationResult<T>[]\n): AnimationResult<T> =>\n  results.length == 1\n    ? results[0]\n    : results.some(result => result.cancelled)\n    ? getCancelledResult(target.get())\n    : results.every(result => result.noop)\n    ? getNoopResult(target.get())\n    : getFinishedResult(\n        target.get(),\n        results.every(result => result.finished)\n      )\n\n/** No-op results are for updates that never start an animation. */\nexport const getNoopResult = (value: any) => ({\n  value,\n  noop: true,\n  finished: true,\n  cancelled: false,\n})\n\nexport const getFinishedResult = (\n  value: any,\n  finished: boolean,\n  cancelled: boolean = false\n) => ({\n  value,\n  finished,\n  cancelled,\n})\n\nexport const getCancelledResult = (value: any) => ({\n  value,\n  cancelled: true,\n  finished: false,\n})\n","import {\n  is,\n  raf,\n  flush,\n  eachProp,\n  Timeout,\n  Globals as G,\n} from '@react-spring/shared'\nimport { Falsy } from '@react-spring/types'\n\nimport { getDefaultProps } from './helpers'\nimport { AnimationTarget, InferState, InferProps } from './types/internal'\nimport { AnimationResult, AsyncResult, SpringChain, SpringToFn } from './types'\nimport { getCancelledResult, getFinishedResult } from './AnimationResult'\n\ntype AsyncTo<T> = SpringChain<T> | SpringToFn<T>\n\n/** @internal */\nexport type RunAsyncProps<T extends AnimationTarget = any> = InferProps<T> & {\n  callId: number\n  parentId?: number\n  cancel: boolean\n  to?: any\n}\n\n/** @internal */\nexport interface RunAsyncState<T extends AnimationTarget = any> {\n  paused: boolean\n  pauseQueue: Set<() => void>\n  resumeQueue: Set<() => void>\n  timeouts: Set<Timeout>\n  asyncId?: number\n  asyncTo?: AsyncTo<InferState<T>>\n  promise?: AsyncResult<T>\n  cancelId?: number\n}\n\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\nexport function runAsync<T extends AnimationTarget>(\n  to: AsyncTo<InferState<T>>,\n  props: RunAsyncProps<T>,\n  state: RunAsyncState<T>,\n  target: T\n): AsyncResult<T> {\n  const { callId, parentId, onRest } = props\n  const { asyncTo: prevTo, promise: prevPromise } = state\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise!\n  }\n\n  return (state.promise = (async () => {\n    state.asyncId = callId\n    state.asyncTo = to\n\n    // The default props of any `animate` calls.\n    const defaultProps = getDefaultProps<InferProps<T>>(props, (value, key) =>\n      // The `onRest` prop is only called when the `runAsync` promise is resolved.\n      key === 'onRest' ? undefined : value\n    )\n\n    let preventBail!: () => void\n    let bail: (error: any) => void\n\n    // This promise is rejected when the animation is interrupted.\n    const bailPromise = new Promise<void>(\n      (resolve, reject) => ((preventBail = resolve), (bail = reject))\n    )\n\n    const bailIfEnded = (bailSignal: BailSignal) => {\n      const bailResult =\n        // The `cancel` prop or `stop` method was used.\n        (callId <= (state.cancelId || 0) && getCancelledResult(target)) ||\n        // The async `to` prop was replaced.\n        (callId !== state.asyncId && getFinishedResult(target, false))\n\n      if (bailResult) {\n        bailSignal.result = bailResult\n\n        // Reject the `bailPromise` to ensure the `runAsync` promise\n        // is not relying on the caller to rethrow the error for us.\n        bail(bailSignal)\n        throw bailSignal\n      }\n    }\n\n    const animate: any = (arg1: any, arg2?: any) => {\n      // Create the bail signal outside the returned promise,\n      // so the generated stack trace is relevant.\n      const bailSignal = new BailSignal()\n      const skipAnimationSignal = new SkipAniamtionSignal()\n\n      return (async () => {\n        if (G.skipAnimation) {\n          /**\n           * We need to stop animations if `skipAnimation`\n           * is set in the Globals\n           *\n           */\n          stopAsync(state)\n\n          // create the rejection error that's handled gracefully\n          skipAnimationSignal.result = getFinishedResult(target, false)\n          bail(skipAnimationSignal)\n          throw skipAnimationSignal\n        }\n\n        bailIfEnded(bailSignal)\n\n        const props: any = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 }\n        props.parentId = callId\n\n        eachProp(defaultProps, (value, key) => {\n          if (is.und(props[key])) {\n            props[key] = value\n          }\n        })\n\n        const result = await target.start(props)\n        bailIfEnded(bailSignal)\n\n        if (state.paused) {\n          await new Promise<void>(resume => {\n            state.resumeQueue.add(resume)\n          })\n        }\n\n        return result\n      })()\n    }\n\n    let result!: AnimationResult<T>\n\n    if (G.skipAnimation) {\n      /**\n       * We need to stop animations if `skipAnimation`\n       * is set in the Globals\n       */\n      stopAsync(state)\n      return getFinishedResult(target, false)\n    }\n\n    try {\n      let animating!: Promise<void>\n\n      // Async sequence\n      if (is.arr(to)) {\n        animating = (async (queue: any[]) => {\n          for (const props of queue) {\n            await animate(props)\n          }\n        })(to)\n      }\n\n      // Async script\n      else {\n        animating = Promise.resolve(to(animate, target.stop.bind(target)))\n      }\n\n      await Promise.all([animating.then(preventBail), bailPromise])\n      result = getFinishedResult(target.get(), true, false)\n\n      // Bail handling\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result\n      } else if (err instanceof SkipAniamtionSignal) {\n        result = err.result\n      } else {\n        throw err\n      }\n\n      // Reset the async state.\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId\n        state.asyncTo = parentId ? prevTo : undefined\n        state.promise = parentId ? prevPromise : undefined\n      }\n    }\n\n    if (is.fun(onRest)) {\n      raf.batchedUpdates(() => {\n        onRest(result, target, target.item)\n      })\n    }\n\n    return result\n  })())\n}\n\n/** Stop the current `runAsync` call with `finished: false` (or with `cancelled: true` when `cancelId` is defined) */\nexport function stopAsync(state: RunAsyncState, cancelId?: number | Falsy) {\n  flush(state.timeouts, t => t.cancel())\n  state.pauseQueue.clear()\n  state.resumeQueue.clear()\n  state.asyncId = state.asyncTo = state.promise = undefined\n  if (cancelId) state.cancelId = cancelId\n}\n\n/** This error is thrown to signal an interrupted async animation. */\nexport class BailSignal extends Error {\n  result!: AnimationResult\n  constructor() {\n    super(\n      'An async animation has been interrupted. You see this error because you ' +\n        'forgot to use `await` or `.catch(...)` on its returned promise.'\n    )\n  }\n}\n\nexport class SkipAniamtionSignal extends Error {\n  result!: AnimationResult\n\n  constructor() {\n    super('SkipAnimationSignal')\n  }\n}\n","import {\n  deprecateInterpolate,\n  frameLoop,\n  FluidValue,\n  Globals as G,\n  callFluidObservers,\n} from '@react-spring/shared'\nimport { InterpolatorArgs } from '@react-spring/types'\nimport { getAnimated } from '@react-spring/animated'\n\nimport { Interpolation } from './Interpolation'\n\nexport const isFrameValue = (value: any): value is FrameValue =>\n  value instanceof FrameValue\n\nlet nextId = 1\n\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\nexport abstract class FrameValue<T = any> extends FluidValue<\n  T,\n  FrameValue.Event<T>\n> {\n  readonly id = nextId++\n\n  abstract key?: string\n  abstract get idle(): boolean\n\n  protected _priority = 0\n\n  get priority() {\n    return this._priority\n  }\n  set priority(priority: number) {\n    if (this._priority != priority) {\n      this._priority = priority\n      this._onPriorityChange(priority)\n    }\n  }\n\n  /** Get the current value */\n  get(): T {\n    const node = getAnimated(this)\n    return node && node.getValue()\n  }\n\n  /** Create a spring that maps our value to another value */\n  to<Out>(...args: InterpolatorArgs<T, Out>) {\n    return G.to(this, args) as Interpolation<T, Out>\n  }\n\n  /** @deprecated Use the `to` method instead. */\n  interpolate<Out>(...args: InterpolatorArgs<T, Out>) {\n    deprecateInterpolate()\n    return G.to(this, args) as Interpolation<T, Out>\n  }\n\n  toJSON() {\n    return this.get()\n  }\n\n  protected observerAdded(count: number) {\n    if (count == 1) this._attach()\n  }\n\n  protected observerRemoved(count: number) {\n    if (count == 0) this._detach()\n  }\n\n  /** @internal */\n  abstract advance(dt: number): void\n\n  /** @internal */\n  abstract eventObserved(_event: FrameValue.Event): void\n\n  /** Called when the first child is added. */\n  protected _attach() {}\n\n  /** Called when the last child is removed. */\n  protected _detach() {}\n\n  /** Tell our children about our new value */\n  protected _onChange(value: T, idle = false) {\n    callFluidObservers(this, {\n      type: 'change',\n      parent: this,\n      value,\n      idle,\n    })\n  }\n\n  /** Tell our children about our new priority */\n  protected _onPriorityChange(priority: number) {\n    if (!this.idle) {\n      frameLoop.sort(this)\n    }\n    callFluidObservers(this, {\n      type: 'priority',\n      parent: this,\n      priority,\n    })\n  }\n}\n\nexport declare namespace FrameValue {\n  /** A parent changed its value */\n  interface ChangeEvent<T = any> {\n    parent: FrameValue<T>\n    type: 'change'\n    value: T\n    idle: boolean\n  }\n\n  /** A parent changed its priority */\n  interface PriorityEvent<T = any> {\n    parent: FrameValue<T>\n    type: 'priority'\n    priority: number\n  }\n\n  /** A parent is done animating */\n  interface IdleEvent<T = any> {\n    parent: FrameValue<T>\n    type: 'idle'\n  }\n\n  /** Events sent to children of `FrameValue` objects */\n  export type Event<T = any> = ChangeEvent<T> | PriorityEvent<T> | IdleEvent<T>\n}\n","/** The property symbol of the current animation phase. */\nconst $P = Symbol.for('SpringPhase')\n\nconst HAS_ANIMATED = 1\nconst IS_ANIMATING = 2\nconst IS_PAUSED = 4\n\n/** Returns true if the `target` has ever animated. */\nexport const hasAnimated = (target: any) => (target[$P] & HAS_ANIMATED) > 0\n\n/** Returns true if the `target` is animating (even if paused). */\nexport const isAnimating = (target: any) => (target[$P] & IS_ANIMATING) > 0\n\n/** Returns true if the `target` is paused (even if idle). */\nexport const isPaused = (target: any) => (target[$P] & IS_PAUSED) > 0\n\n/** Set the active bit of the `target` phase. */\nexport const setActiveBit = (target: any, active: boolean) =>\n  active\n    ? (target[$P] |= IS_ANIMATING | HAS_ANIMATED)\n    : (target[$P] &= ~IS_ANIMATING)\n\nexport const setPausedBit = (target: any, paused: boolean) =>\n  paused ? (target[$P] |= IS_PAUSED) : (target[$P] &= ~IS_PAUSED)\n","import {\n  is,\n  raf,\n  each,\n  isEqual,\n  toArray,\n  eachProp,\n  frameLoop,\n  flushCalls,\n  getFluidValue,\n  isAnimatedString,\n  FluidValue,\n  Globals as G,\n  callFluidObservers,\n  hasFluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n  getFluidObservers,\n} from '@react-spring/shared'\nimport {\n  Animated,\n  AnimatedValue,\n  AnimatedString,\n  getPayload,\n  getAnimated,\n  setAnimated,\n  getAnimatedType,\n} from '@react-spring/animated'\nimport { Lookup } from '@react-spring/types'\n\nimport { Animation } from './Animation'\nimport { mergeConfig } from './AnimationConfig'\nimport { scheduleProps } from './scheduleProps'\nimport { runAsync, RunAsyncState, RunAsyncProps, stopAsync } from './runAsync'\nimport {\n  callProp,\n  computeGoal,\n  matchProp,\n  inferTo,\n  getDefaultProps,\n  getDefaultProp,\n  isAsyncTo,\n  resolveProp,\n} from './helpers'\nimport { FrameValue, isFrameValue } from './FrameValue'\nimport {\n  isAnimating,\n  isPaused,\n  setPausedBit,\n  hasAnimated,\n  setActiveBit,\n} from './SpringPhase'\nimport {\n  AnimationRange,\n  AnimationResolver,\n  EventKey,\n  PickEventFns,\n} from './types/internal'\nimport { AsyncResult, SpringUpdate, VelocityProp, SpringProps } from './types'\nimport {\n  getCombinedResult,\n  getCancelledResult,\n  getFinishedResult,\n  getNoopResult,\n} from './AnimationResult'\n\ndeclare const console: any\n\ninterface DefaultSpringProps<T>\n  extends Pick<SpringProps<T>, 'pause' | 'cancel' | 'immediate' | 'config'>,\n    PickEventFns<SpringProps<T>> {}\n\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\nexport class SpringValue<T = any> extends FrameValue<T> {\n  /** The property name used when `to` or `from` is an object. Useful when debugging too. */\n  key?: string\n\n  /** The animation state */\n  animation = new Animation<T>()\n\n  /** The queue of pending props */\n  queue?: SpringUpdate<T>[]\n\n  /** Some props have customizable default values */\n  defaultProps: DefaultSpringProps<T> = {}\n\n  /** The state for `runAsync` calls */\n  protected _state: RunAsyncState<SpringValue<T>> = {\n    paused: false,\n    pauseQueue: new Set(),\n    resumeQueue: new Set(),\n    timeouts: new Set(),\n  }\n\n  /** The promise resolvers of pending `start` calls */\n  protected _pendingCalls = new Set<AnimationResolver<this>>()\n\n  /** The counter for tracking `scheduleProps` calls */\n  protected _lastCallId = 0\n\n  /** The last `scheduleProps` call that changed the `to` prop */\n  protected _lastToId = 0\n\n  protected _memoizedDuration = 0\n\n  constructor(from: Exclude<T, object>, props?: SpringUpdate<T>)\n  constructor(props?: SpringUpdate<T>)\n  constructor(arg1?: any, arg2?: any) {\n    super()\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 }\n      if (is.und(props.default)) {\n        props.default = true\n      }\n      this.start(props)\n    }\n  }\n\n  /** Equals true when not advancing on each frame. */\n  get idle() {\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this)\n  }\n\n  get goal() {\n    return getFluidValue(this.animation.to) as T\n  }\n\n  get velocity(): VelocityProp<T> {\n    const node = getAnimated(this)!\n    return (node instanceof AnimatedValue\n      ? node.lastVelocity || 0\n      : node.getPayload().map(node => node.lastVelocity || 0)) as any\n  }\n\n  /**\n   * When true, this value has been animated at least once.\n   */\n  get hasAnimated() {\n    return hasAnimated(this)\n  }\n\n  /**\n   * When true, this value has an unfinished animation,\n   * which is either active or paused.\n   */\n  get isAnimating() {\n    return isAnimating(this)\n  }\n\n  /**\n   * When true, all current and future animations are paused.\n   */\n  get isPaused() {\n    return isPaused(this)\n  }\n\n  /** Advance the current animation by a number of milliseconds */\n  advance(dt: number) {\n    let idle = true\n    let changed = false\n\n    const anim = this.animation\n    let { config, toValues } = anim\n\n    const payload = getPayload(anim.to)\n    if (!payload && hasFluidValue(anim.to)) {\n      toValues = toArray(getFluidValue(anim.to)) as any\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return\n\n      const to =\n        // Animated strings always go from 0 to 1.\n        node.constructor == AnimatedString\n          ? 1\n          : payload\n          ? payload[i].lastPosition\n          : toValues![i]\n\n      let finished = anim.immediate\n      let position = to\n\n      if (!finished) {\n        position = node.lastPosition\n\n        // Loose springs never move.\n        if (config.tension <= 0) {\n          node.done = true\n          return\n        }\n\n        let elapsed = (node.elapsedTime += dt)\n        const from = anim.fromValues[i]\n\n        const v0 =\n          node.v0 != null\n            ? node.v0\n            : (node.v0 = is.arr(config.velocity)\n                ? config.velocity[i]\n                : config.velocity)\n\n        let velocity: number\n\n        // Duration easing\n        if (!is.und(config.duration)) {\n          let p = 1\n          if (config.duration > 0) {\n            /**\n             * Here we check if the duration has changed in the config\n             * and if so update the elapsed time to the percentage\n             * of completition so there is no jank in the animation\n             * https://github.com/pmndrs/react-spring/issues/1163\n             */\n            if (this._memoizedDuration !== config.duration) {\n              // update the memoized version to the new duration\n              this._memoizedDuration = config.duration\n\n              // if the value has started animating we need to update it\n              if (node.durationProgress > 0) {\n                // set elapsed time to be the same percentage of progress as the previous duration\n                node.elapsedTime = config.duration * node.durationProgress\n                // add the delta so the below updates work as expected\n                elapsed = node.elapsedTime += dt\n              }\n            }\n\n            // calculate the new progress\n            p = (config.progress || 0) + elapsed / this._memoizedDuration\n            // p is clamped between 0-1\n            p = p > 1 ? 1 : p < 0 ? 0 : p\n            // store our new progress\n            node.durationProgress = p\n          }\n\n          position = from + config.easing(p) * (to - from)\n          velocity = (position - node.lastPosition) / dt\n\n          finished = p == 1\n        }\n\n        // Decay easing\n        else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay\n          const e = Math.exp(-(1 - decay) * elapsed)\n\n          position = from + (v0 / (1 - decay)) * (1 - e)\n          finished = Math.abs(node.lastPosition - position) < 0.1\n\n          // derivative of position\n          velocity = v0 * e\n        }\n\n        // Spring easing\n        else {\n          velocity = node.lastVelocity == null ? v0 : node.lastVelocity\n\n          /** The smallest distance from a value before being treated like said value. */\n          const precision =\n            config.precision ||\n            (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001))\n\n          /** The velocity at which movement is essentially none */\n          const restVelocity = config.restVelocity || precision / 10\n\n          // Bouncing is opt-in (not to be confused with overshooting)\n          const bounceFactor = config.clamp ? 0 : config.bounce!\n          const canBounce = !is.und(bounceFactor)\n\n          /** When `true`, the value is increasing over time */\n          const isGrowing = from == to ? node.v0 > 0 : from < to\n\n          /** When `true`, the velocity is considered moving */\n          let isMoving!: boolean\n\n          /** When `true`, the velocity is being deflected or clamped */\n          let isBouncing = false\n\n          const step = 1 // 1ms\n          const numSteps = Math.ceil(dt / step)\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity\n\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision\n              if (finished) {\n                break\n              }\n            }\n\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing\n\n              // Invert the velocity with a magnitude, or clamp it.\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor\n                position = to\n              }\n            }\n\n            const springForce = -config.tension * 0.000001 * (position - to)\n            const dampingForce = -config.friction * 0.001 * velocity\n            const acceleration = (springForce + dampingForce) / config.mass // pt/ms^2\n\n            velocity = velocity + acceleration * step // pt/ms\n            position = position + velocity * step\n          }\n        }\n\n        node.lastVelocity = velocity\n\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this)\n          finished = true\n        }\n      }\n\n      // Parent springs must finish before their children can.\n      if (payload && !payload[i].done) {\n        finished = false\n      }\n\n      if (finished) {\n        node.done = true\n      } else {\n        idle = false\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true\n      }\n    })\n\n    const node = getAnimated(this)!\n    if (idle) {\n      const value = getFluidValue(anim.to)\n      if (node.setValue(value) || changed) {\n        this._onChange(value)\n      }\n      this._stop()\n    } else if (changed) {\n      this._onChange(node.getValue())\n    }\n  }\n\n  /** Set the current value, while stopping the current animation */\n  set(value: T | FluidValue<T>) {\n    raf.batchedUpdates(() => {\n      this._stop()\n\n      // These override the current value and goal value that may have\n      // been updated by `onRest` handlers in the `_stop` call above.\n      this._focus(value)\n      this._set(value)\n    })\n    return this\n  }\n\n  /**\n   * Freeze the active animation in time, as well as any updates merged\n   * before `resume` is called.\n   */\n  pause() {\n    this._update({ pause: true })\n  }\n\n  /** Resume the animation if paused. */\n  resume() {\n    this._update({ pause: false })\n  }\n\n  /** Skip to the end of the current animation. */\n  finish() {\n    if (isAnimating(this)) {\n      const { to, config } = this.animation\n      raf.batchedUpdates(() => {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        this._onStart()\n\n        // Jump to the goal value, except for decay animations\n        // which have an undefined goal value.\n        if (!config.decay) {\n          this._set(to, false)\n        }\n\n        this._stop()\n      })\n    }\n    return this\n  }\n\n  /** Push props into the pending queue. */\n  update(props: SpringUpdate<T>) {\n    const queue = this.queue || (this.queue = [])\n    queue.push(props)\n    return this\n  }\n\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n  start(): AsyncResult<this>\n\n  start(props: SpringUpdate<T>): AsyncResult<this>\n\n  start(to: T, props?: SpringProps<T>): AsyncResult<this>\n\n  start(to?: T | SpringUpdate<T>, arg2?: SpringProps<T>) {\n    let queue: SpringUpdate<T>[]\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : { ...arg2, to }]\n    } else {\n      queue = this.queue || []\n      this.queue = []\n    }\n\n    return Promise.all(queue.map(props => this._update(props))).then(results =>\n      getCombinedResult(this, results)\n    )\n  }\n\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n  stop(cancel?: boolean) {\n    const { to } = this.animation\n\n    // The current value becomes the goal value.\n    this._focus(this.get())\n\n    stopAsync(this._state, cancel && this._lastCallId)\n    raf.batchedUpdates(() => this._stop(to, cancel))\n\n    return this\n  }\n\n  /** Restart the animation. */\n  reset() {\n    this._update({ reset: true })\n  }\n\n  /** @internal */\n  eventObserved(event: FrameValue.Event) {\n    if (event.type == 'change') {\n      this._start()\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1\n    }\n  }\n\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n  protected _prepareNode(props: {\n    to?: any\n    from?: any\n    reverse?: boolean\n    default?: any\n  }) {\n    const key = this.key || ''\n\n    let { to, from } = props\n\n    to = is.obj(to) ? to[key] : to\n    if (to == null || isAsyncTo(to)) {\n      to = undefined\n    }\n\n    from = is.obj(from) ? from[key] : from\n    if (from == null) {\n      from = undefined\n    }\n\n    // Create the range now to avoid \"reverse\" logic.\n    const range = { to, from }\n\n    // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n    if (!hasAnimated(this)) {\n      if (props.reverse) [to, from] = [from, to]\n\n      from = getFluidValue(from)\n      if (!is.und(from)) {\n        this._set(from)\n      }\n      // Use the \"to\" value if our node is undefined.\n      else if (!getAnimated(this)) {\n        this._set(to)\n      }\n    }\n\n    return range\n  }\n\n  /** Every update is processed by this method before merging. */\n  protected _update(\n    { ...props }: SpringProps<T>,\n    isLoop?: boolean\n  ): AsyncResult<SpringValue<T>> {\n    const { key, defaultProps } = this\n\n    // Update the default props immediately.\n    if (props.default)\n      Object.assign(\n        defaultProps,\n        getDefaultProps(props, (value, prop) =>\n          /^on/.test(prop) ? resolveProp(value, key) : value\n        )\n      )\n\n    mergeActiveFn(this, props, 'onProps')\n    sendEvent(this, 'onProps', props, this)\n\n    // Ensure the initial value can be accessed by animated components.\n    const range = this._prepareNode(props)\n\n    if (Object.isFrozen(this)) {\n      throw Error(\n        'Cannot animate a `SpringValue` object that is frozen. ' +\n          'Did you forget to pass your component to `animated(...)` before animating its props?'\n      )\n    }\n\n    const state = this._state\n    return scheduleProps(++this._lastCallId, {\n      key,\n      props,\n      defaultProps,\n      state,\n      actions: {\n        pause: () => {\n          if (!isPaused(this)) {\n            setPausedBit(this, true)\n            flushCalls(state.pauseQueue)\n            sendEvent(\n              this,\n              'onPause',\n              getFinishedResult(this, checkFinished(this, this.animation.to)),\n              this\n            )\n          }\n        },\n        resume: () => {\n          if (isPaused(this)) {\n            setPausedBit(this, false)\n            if (isAnimating(this)) {\n              this._resume()\n            }\n            flushCalls(state.resumeQueue)\n            sendEvent(\n              this,\n              'onResume',\n              getFinishedResult(this, checkFinished(this, this.animation.to)),\n              this\n            )\n          }\n        },\n        start: this._merge.bind(this, range),\n      },\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props)\n        if (nextProps) {\n          return this._update(nextProps, true)\n        }\n      }\n      return result\n    })\n  }\n\n  /** Merge props into the current animation */\n  protected _merge(\n    range: AnimationRange<T>,\n    props: RunAsyncProps<SpringValue<T>>,\n    resolve: AnimationResolver<SpringValue<T>>\n  ): void {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true)\n      return resolve(getCancelledResult(this))\n    }\n\n    /** The \"to\" prop is defined. */\n    const hasToProp = !is.und(range.to)\n\n    /** The \"from\" prop is defined. */\n    const hasFromProp = !is.und(range.from)\n\n    // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId\n      } else {\n        return resolve(getCancelledResult(this))\n      }\n    }\n\n    const { key, defaultProps, animation: anim } = this\n    const { to: prevTo, from: prevFrom } = anim\n    let { to = prevTo, from = prevFrom } = range\n\n    // Focus the \"from\" value if changing without a \"to\" value.\n    // For default updates, do this only if no \"to\" value exists.\n    if (hasFromProp && !hasToProp && (!props.default || is.und(to))) {\n      to = from\n    }\n\n    // Flip the current range if \"reverse\" is true.\n    if (props.reverse) [to, from] = [from, to]\n\n    /** The \"from\" value is changing. */\n    const hasFromChanged = !isEqual(from, prevFrom)\n\n    if (hasFromChanged) {\n      anim.from = from\n    }\n\n    // Coerce \"from\" into a static value.\n    from = getFluidValue(from)\n\n    /** The \"to\" value is changing. */\n    const hasToChanged = !isEqual(to, prevTo)\n\n    if (hasToChanged) {\n      this._focus(to)\n    }\n\n    /** The \"to\" prop is async. */\n    const hasAsyncTo = isAsyncTo(props.to)\n\n    const { config } = anim\n    const { decay, velocity } = config\n\n    // Reset to default velocity when goal values are defined.\n    if (hasToProp || hasFromProp) {\n      config.velocity = 0\n    }\n\n    // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(\n        config,\n        callProp(props.config, key!),\n        // Avoid calling the same \"config\" prop twice.\n        props.config !== defaultProps.config\n          ? callProp(defaultProps.config, key!)\n          : void 0\n      )\n    }\n\n    // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n    let node = getAnimated(this)\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true))\n    }\n\n    /** When true, start at the \"from\" value. */\n    const reset =\n      // When `reset` is undefined, the `from` prop implies `reset: true`,\n      // except for declarative updates. When `reset` is defined, there\n      // must exist a value to animate from.\n      is.und(props.reset)\n        ? hasFromProp && !props.default\n        : !is.und(from) && matchProp(props.reset, key)\n\n    // The current value, where the animation starts from.\n    const value = reset ? (from as T) : this.get()\n\n    // The animation ends at this value, unless \"to\" is fluid.\n    const goal = computeGoal<any>(to)\n\n    // Only specific types can be animated to/from.\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal)\n\n    // When true, the value changes instantly on the next frame.\n    const immediate =\n      !hasAsyncTo &&\n      (!isAnimatable ||\n        matchProp(defaultProps.immediate || props.immediate, key))\n\n    if (hasToChanged) {\n      const nodeType = getAnimatedType(to)\n      if (nodeType !== node.constructor) {\n        if (immediate) {\n          node = this._set(goal)!\n        } else\n          throw Error(\n            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`\n          )\n      }\n    }\n\n    // The type of Animated node for the goal value.\n    const goalType = node.constructor\n\n    // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n    let started = hasFluidValue(to)\n    let finished = false\n\n    if (!started) {\n      // When true, the current value has probably changed.\n      const hasValueChanged = reset || (!hasAnimated(this) && hasFromChanged)\n\n      // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal)\n        started = !finished\n      }\n\n      // Changing \"decay\" or \"velocity\" starts the animation.\n      if (\n        !isEqual(config.decay, decay) ||\n        !isEqual(config.velocity, velocity)\n      ) {\n        started = true\n      }\n    }\n\n    // Was the goal value set to the current value while animating?\n    if (finished && isAnimating(this)) {\n      // If the first frame has passed, allow the animation to\n      // overshoot instead of stopping abruptly.\n      if (anim.changed && !reset) {\n        started = true\n      }\n      // Stop the animation before its first frame.\n      else if (!started) {\n        this._stop(prevTo)\n      }\n    }\n\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || hasFluidValue(prevTo)) {\n        anim.values = node.getPayload()\n        anim.toValues = hasFluidValue(to)\n          ? null\n          : goalType == AnimatedString\n          ? [1]\n          : toArray(goal)\n      }\n\n      if (anim.immediate != immediate) {\n        anim.immediate = immediate\n\n        // Ensure the immediate goal is used as from value.\n        if (!immediate && !reset) {\n          this._set(prevTo)\n        }\n      }\n\n      if (started) {\n        const { onRest } = anim\n\n        // Set the active handlers when an animation starts.\n        each(ACTIVE_EVENTS, type => mergeActiveFn(this, props, type))\n\n        const result = getFinishedResult(this, checkFinished(this, prevTo))\n        flushCalls(this._pendingCalls, result)\n        this._pendingCalls.add(resolve)\n\n        if (anim.changed)\n          raf.batchedUpdates(() => {\n            // Ensure `onStart` can be called after a reset.\n            anim.changed = !reset\n\n            // Call the active `onRest` handler from the interrupted animation.\n            onRest?.(result, this)\n\n            // Notify the default `onRest` of the reset, but wait for the\n            // first frame to pass before sending an `onStart` event.\n            if (reset) {\n              callProp(defaultProps.onRest, result)\n            }\n            // Call the active `onStart` handler here since the first frame\n            // has already passed, which means this is a goal update and not\n            // an entirely new animation.\n            else {\n              anim.onStart?.(result, this)\n            }\n          })\n      }\n    }\n\n    if (reset) {\n      this._set(value)\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this))\n    }\n\n    // Start an animation\n    else if (started) {\n      this._start()\n    }\n\n    // Postpone promise resolution until the animation is finished,\n    // so that no-op updates still resolve at the expected time.\n    else if (isAnimating(this) && !hasToChanged) {\n      this._pendingCalls.add(resolve)\n    }\n\n    // Resolve our promise immediately.\n    else {\n      resolve(getNoopResult(value))\n    }\n  }\n\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n  protected _focus(value: T | FluidValue<T>) {\n    const anim = this.animation\n    if (value !== anim.to) {\n      if (getFluidObservers(this)) {\n        this._detach()\n      }\n      anim.to = value\n      if (getFluidObservers(this)) {\n        this._attach()\n      }\n    }\n  }\n\n  protected _attach() {\n    let priority = 0\n\n    const { to } = this.animation\n    if (hasFluidValue(to)) {\n      addFluidObserver(to, this)\n      if (isFrameValue(to)) {\n        priority = to.priority + 1\n      }\n    }\n\n    this.priority = priority\n  }\n\n  protected _detach() {\n    const { to } = this.animation\n    if (hasFluidValue(to)) {\n      removeFluidObserver(to, this)\n    }\n  }\n\n  /**\n   * Update the current value from outside the frameloop,\n   * and return the `Animated` node.\n   */\n  protected _set(arg: T | FluidValue<T>, idle = true): Animated | undefined {\n    const value = getFluidValue(arg)\n    if (!is.und(value)) {\n      const oldNode = getAnimated(this)\n      if (!oldNode || !isEqual(value, oldNode.getValue())) {\n        // Create a new node or update the existing node.\n        const nodeType = getAnimatedType(value)\n        if (!oldNode || oldNode.constructor != nodeType) {\n          setAnimated(this, nodeType.create(value))\n        } else {\n          oldNode.setValue(value)\n        }\n        // Never emit a \"change\" event for the initial value.\n        if (oldNode) {\n          raf.batchedUpdates(() => {\n            this._onChange(value, idle)\n          })\n        }\n      }\n    }\n    return getAnimated(this)\n  }\n\n  protected _onStart() {\n    const anim = this.animation\n    if (!anim.changed) {\n      anim.changed = true\n      sendEvent(\n        this,\n        'onStart',\n        getFinishedResult(this, checkFinished(this, anim.to)),\n        this\n      )\n    }\n  }\n\n  protected _onChange(value: T, idle?: boolean) {\n    if (!idle) {\n      this._onStart()\n      callProp(this.animation.onChange, value, this)\n    }\n    callProp(this.defaultProps.onChange, value, this)\n    super._onChange(value, idle)\n  }\n\n  // This method resets the animation state (even if already animating) to\n  // ensure the latest from/to range is used, and it also ensures this spring\n  // is added to the frameloop.\n  protected _start() {\n    const anim = this.animation\n\n    // Reset the state of each Animated node.\n    getAnimated(this)!.reset(getFluidValue(anim.to))\n\n    // Use the current values as the from values.\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition)\n    }\n\n    if (!isAnimating(this)) {\n      setActiveBit(this, true)\n      if (!isPaused(this)) {\n        this._resume()\n      }\n    }\n  }\n\n  protected _resume() {\n    // The \"skipAnimation\" global avoids the frameloop.\n    if (G.skipAnimation) {\n      this.finish()\n    } else {\n      frameLoop.start(this)\n    }\n  }\n\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n  protected _stop(goal?: any, cancel?: boolean) {\n    if (isAnimating(this)) {\n      setActiveBit(this, false)\n\n      const anim = this.animation\n      each(anim.values, node => {\n        node.done = true\n      })\n\n      // These active handlers must be reset to undefined or else\n      // they could be called while idle. But keep them defined\n      // when the goal value is dynamic.\n      if (anim.toValues) {\n        anim.onChange = anim.onPause = anim.onResume = undefined\n      }\n\n      callFluidObservers(this, {\n        type: 'idle',\n        parent: this,\n      })\n\n      const result = cancel\n        ? getCancelledResult(this.get())\n        : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to))\n\n      flushCalls(this._pendingCalls, result)\n      if (anim.changed) {\n        anim.changed = false\n        sendEvent(this, 'onRest', result, this)\n      }\n    }\n  }\n}\n\n/** Returns true when the current value and goal value are equal. */\nfunction checkFinished<T>(target: SpringValue<T>, to: T | FluidValue<T>) {\n  const goal = computeGoal(to)\n  const value = computeGoal(target.get())\n  return isEqual(value, goal)\n}\n\nexport function createLoopUpdate<T>(\n  props: T & { loop?: any; to?: any; from?: any; reverse?: any },\n  loop = props.loop,\n  to = props.to\n): T | undefined {\n  let loopRet = callProp(loop)\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet)\n    const reverse = (overrides || props).reverse\n    const reset = !overrides || overrides.reset\n    return createUpdate({\n      ...props,\n      loop,\n\n      // Avoid updating default props when looping.\n      default: false,\n\n      // Never loop the `pause` prop.\n      pause: undefined,\n\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || isAsyncTo(to) ? to : undefined,\n\n      // Ignore the \"from\" prop except on reset.\n      from: reset ? props.from : undefined,\n      reset,\n\n      // The \"loop\" prop can return a \"useSpring\" props object to\n      // override any of the original props.\n      ...overrides,\n    })\n  }\n}\n\n/**\n * Return a new object based on the given `props`.\n *\n * - All non-reserved props are moved into the `to` prop object.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\nexport function createUpdate(props: any) {\n  const { to, from } = (props = inferTo(props))\n\n  // Collect the keys affected by this update.\n  const keys = new Set<string>()\n\n  if (is.obj(to)) findDefined(to, keys)\n  if (is.obj(from)) findDefined(from, keys)\n\n  // The \"keys\" prop helps in applying updates to affected keys only.\n  props.keys = keys.size ? Array.from(keys) : null\n\n  return props\n}\n\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\nexport function declareUpdate(props: any) {\n  const update = createUpdate(props)\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update)\n  }\n  return update\n}\n\n/** Find keys with defined values */\nfunction findDefined(values: Lookup, keys: Set<string>) {\n  eachProp(values, (value, key) => value != null && keys.add(key as any))\n}\n\n/** Event props with \"active handler\" support */\nconst ACTIVE_EVENTS = [\n  'onStart',\n  'onRest',\n  'onChange',\n  'onPause',\n  'onResume',\n] as const\n\nfunction mergeActiveFn<T, P extends EventKey>(\n  target: SpringValue<T>,\n  props: SpringProps<T>,\n  type: P\n) {\n  target.animation[type] =\n    props[type] !== getDefaultProp(props, type)\n      ? resolveProp<any>(props[type], target.key)\n      : undefined\n}\n\ntype EventArgs<T, P extends EventKey> = Parameters<\n  Extract<SpringProps<T>[P], Function>\n>\n\n/** Call the active handler first, then the default handler. */\nfunction sendEvent<T, P extends EventKey>(\n  target: SpringValue<T>,\n  type: P,\n  ...args: EventArgs<T, P>\n) {\n  target.animation[type]?.(...(args as [any, any]))\n  target.defaultProps[type]?.(...(args as [any, any]))\n}\n","import { OneOrMore, UnknownProps, Lookup, Falsy } from '@react-spring/types'\nimport {\n  is,\n  raf,\n  each,\n  noop,\n  flush,\n  toArray,\n  eachProp,\n  flushCalls,\n  addFluidObserver,\n  FluidObserver,\n} from '@react-spring/shared'\n\nimport { getDefaultProp } from './helpers'\nimport { FrameValue } from './FrameValue'\nimport { SpringRef } from './SpringRef'\nimport { SpringValue, createLoopUpdate, createUpdate } from './SpringValue'\nimport { getCancelledResult, getCombinedResult } from './AnimationResult'\nimport { runAsync, RunAsyncState, stopAsync } from './runAsync'\nimport { scheduleProps } from './scheduleProps'\nimport {\n  AnimationResult,\n  AsyncResult,\n  ControllerFlushFn,\n  ControllerUpdate,\n  OnChange,\n  OnRest,\n  OnStart,\n  SpringValues,\n} from './types'\n\n/** Events batched by the `Controller` class */\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'] as const\n\nlet nextId = 1\n\n/** Queue of pending updates for a `Controller` instance. */\nexport interface ControllerQueue<State extends Lookup = Lookup>\n  extends Array<\n    ControllerUpdate<State, any> & {\n      /** The keys affected by this update. When null, all keys are affected. */\n      keys: string[] | null\n    }\n  > {}\n\nexport class Controller<State extends Lookup = Lookup> {\n  readonly id = nextId++\n\n  /** The animated values */\n  springs: SpringValues<State> = {} as any\n\n  /** The queue of props passed to the `update` method. */\n  queue: ControllerQueue<State> = []\n\n  /**\n   * The injected ref. When defined, render-based updates are pushed\n   * onto the `queue` instead of being auto-started.\n   */\n  ref?: SpringRef<State>\n\n  /** Custom handler for flushing update queues */\n  protected _flush?: ControllerFlushFn<this>\n\n  /** These props are used by all future spring values */\n  protected _initialProps?: Lookup\n\n  /** The counter for tracking `scheduleProps` calls */\n  protected _lastAsyncId = 0\n\n  /** The values currently being animated */\n  protected _active = new Set<FrameValue>()\n\n  /** The values that changed recently */\n  protected _changed = new Set<FrameValue>()\n\n  /** Equals false when `onStart` listeners can be called */\n  protected _started = false\n\n  private _item?: any\n\n  /** State used by the `runAsync` function */\n  protected _state: RunAsyncState<this> = {\n    paused: false,\n    pauseQueue: new Set(),\n    resumeQueue: new Set(),\n    timeouts: new Set(),\n  }\n\n  /** The event queues that are flushed once per frame maximum */\n  protected _events = {\n    onStart: new Map<\n      OnStart<SpringValue<State>, Controller<State>, any>,\n      AnimationResult\n    >(),\n    onChange: new Map<\n      OnChange<SpringValue<State>, Controller<State>, any>,\n      AnimationResult\n    >(),\n    onRest: new Map<\n      OnRest<SpringValue<State>, Controller<State>, any>,\n      AnimationResult\n    >(),\n  }\n\n  constructor(\n    props?: ControllerUpdate<State> | null,\n    flush?: ControllerFlushFn<any>\n  ) {\n    this._onFrame = this._onFrame.bind(this)\n    if (flush) {\n      this._flush = flush\n    }\n    if (props) {\n      this.start({ default: true, ...props })\n    }\n  }\n\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n  get idle() {\n    return (\n      !this._state.asyncTo &&\n      Object.values(this.springs as Lookup<SpringValue>).every(\n        spring => spring.idle\n      )\n    )\n  }\n\n  get item() {\n    return this._item\n  }\n\n  set item(item) {\n    this._item = item\n  }\n\n  /** Get the current values of our springs */\n  get(): State & UnknownProps {\n    const values: any = {}\n    this.each((spring, key) => (values[key] = spring.get()))\n    return values\n  }\n\n  /** Set the current values without animating. */\n  set(values: Partial<State>) {\n    for (const key in values) {\n      const value = values[key]\n      if (!is.und(value)) {\n        this.springs[key].set(value)\n      }\n    }\n  }\n\n  /** Push an update onto the queue of each value. */\n  update(props: ControllerUpdate<State> | Falsy) {\n    if (props) {\n      this.queue.push(createUpdate(props))\n    }\n    return this\n  }\n\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n  start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this> {\n    let { queue } = this as any\n    if (props) {\n      queue = toArray<any>(props).map(createUpdate)\n    } else {\n      this.queue = []\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue)\n    }\n\n    prepareKeys(this, queue)\n    return flushUpdateQueue(this, queue)\n  }\n\n  /** Stop all animations. */\n  stop(): this\n  /** Stop animations for the given keys. */\n  stop(keys: OneOrMore<string>): this\n  /** Cancel all animations. */\n  stop(cancel: boolean): this\n  /** Cancel animations for the given keys. */\n  stop(cancel: boolean, keys: OneOrMore<string>): this\n  /** Stop some or all animations. */\n  stop(keys?: OneOrMore<string>): this\n  /** Cancel some or all animations. */\n  stop(cancel: boolean, keys?: OneOrMore<string>): this\n  /** @internal */\n  stop(arg?: boolean | OneOrMore<string>, keys?: OneOrMore<string>) {\n    if (arg !== !!arg) {\n      keys = arg as OneOrMore<string>\n    }\n    if (keys) {\n      const springs = this.springs as Lookup<SpringValue>\n      each(toArray(keys), key => springs[key].stop(!!arg))\n    } else {\n      stopAsync(this._state, this._lastAsyncId)\n      this.each(spring => spring.stop(!!arg))\n    }\n    return this\n  }\n\n  /** Freeze the active animation in time */\n  pause(keys?: OneOrMore<string>) {\n    if (is.und(keys)) {\n      this.start({ pause: true })\n    } else {\n      const springs = this.springs as Lookup<SpringValue>\n      each(toArray(keys), key => springs[key].pause())\n    }\n    return this\n  }\n\n  /** Resume the animation if paused. */\n  resume(keys?: OneOrMore<string>) {\n    if (is.und(keys)) {\n      this.start({ pause: false })\n    } else {\n      const springs = this.springs as Lookup<SpringValue>\n      each(toArray(keys), key => springs[key].resume())\n    }\n    return this\n  }\n\n  /** Call a function once per spring value */\n  each(iterator: (spring: SpringValue, key: string) => void) {\n    eachProp(this.springs, iterator as any)\n  }\n\n  /** @internal Called at the end of every animation frame */\n  protected _onFrame() {\n    const { onStart, onChange, onRest } = this._events\n\n    const active = this._active.size > 0\n    const changed = this._changed.size > 0\n\n    if ((active && !this._started) || (changed && !this._started)) {\n      this._started = true\n      flush(onStart, ([onStart, result]) => {\n        result.value = this.get()\n        onStart(result, this, this._item)\n      })\n    }\n\n    const idle = !active && this._started\n    const values = changed || (idle && onRest.size) ? this.get() : null\n\n    if (changed && onChange.size) {\n      flush(onChange, ([onChange, result]) => {\n        result.value = values\n        onChange(result, this, this._item)\n      })\n    }\n\n    // The \"onRest\" queue is only flushed when all springs are idle.\n    if (idle) {\n      this._started = false\n      flush(onRest, ([onRest, result]) => {\n        result.value = values\n        onRest(result, this, this._item)\n      })\n    }\n  }\n\n  /** @internal */\n  eventObserved(event: FrameValue.Event) {\n    if (event.type == 'change') {\n      this._changed.add(event.parent)\n      if (!event.idle) {\n        this._active.add(event.parent)\n      }\n    } else if (event.type == 'idle') {\n      this._active.delete(event.parent)\n    }\n    // The `onFrame` handler runs when a parent is changed or idle.\n    else return\n    raf.onFrame(this._onFrame)\n  }\n}\n\n/**\n * Warning: Props might be mutated.\n */\nexport function flushUpdateQueue(\n  ctrl: Controller<any>,\n  queue: ControllerQueue\n) {\n  return Promise.all(\n    queue.map(props => flushUpdate(ctrl, props))\n  ).then(results => getCombinedResult(ctrl, results))\n}\n\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\nexport async function flushUpdate(\n  ctrl: Controller<any>,\n  props: ControllerQueue[number],\n  isLoop?: boolean\n): AsyncResult {\n  const { keys, to, from, loop, onRest, onResolve } = props\n  const defaults = is.obj(props.default) && props.default\n\n  // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n  if (loop) {\n    props.loop = false\n  }\n\n  // Treat false like null, which gets ignored.\n  if (to === false) props.to = null\n  if (from === false) props.from = null\n\n  const asyncTo = is.arr(to) || is.fun(to) ? to : undefined\n  if (asyncTo) {\n    props.to = undefined\n    props.onRest = undefined\n    if (defaults) {\n      defaults.onRest = undefined\n    }\n  }\n  // For certain events, use batching to prevent multiple calls per frame.\n  // However, batching is avoided when the `to` prop is async, because any\n  // event props are used as default props instead.\n  else {\n    each(BATCHED_EVENTS, key => {\n      const handler: any = props[key]\n      if (is.fun(handler)) {\n        const queue = ctrl['_events'][key]\n        props[key] = (({ finished, cancelled }: AnimationResult) => {\n          const result = queue.get(handler)\n          if (result) {\n            if (!finished) result.finished = false\n            if (cancelled) result.cancelled = true\n          } else {\n            // The \"value\" is set before the \"handler\" is called.\n            queue.set(handler, {\n              value: null,\n              finished: finished || false,\n              cancelled: cancelled || false,\n            })\n          }\n        }) as any\n\n        // Avoid using a batched `handler` as a default prop.\n        if (defaults) {\n          defaults[key] = props[key] as any\n        }\n      }\n    })\n  }\n\n  const state = ctrl['_state']\n\n  // Pause/resume the `asyncTo` when `props.pause` is true/false.\n  if (props.pause === !state.paused) {\n    state.paused = props.pause\n    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue)\n  }\n  // When a controller is paused, its values are also paused.\n  else if (state.paused) {\n    props.pause = true\n  }\n\n  const promises: AsyncResult[] = (keys || Object.keys(ctrl.springs)).map(key =>\n    ctrl.springs[key]!.start(props as any)\n  )\n\n  const cancel =\n    props.cancel === true || getDefaultProp(props, 'cancel') === true\n\n  if (asyncTo || (cancel && state.asyncId)) {\n    promises.push(\n      scheduleProps(++ctrl['_lastAsyncId'], {\n        props,\n        state,\n        actions: {\n          pause: noop,\n          resume: noop,\n          start(props, resolve) {\n            if (cancel) {\n              stopAsync(state, ctrl['_lastAsyncId'])\n              resolve(getCancelledResult(ctrl))\n            } else {\n              props.onRest = onRest\n              resolve(runAsync(asyncTo!, props, state, ctrl))\n            }\n          },\n        },\n      })\n    )\n  }\n\n  // Pause after updating each spring, so they can be resumed separately\n  // and so their default `pause` and `cancel` props are updated.\n  if (state.paused) {\n    // Ensure `this` must be resumed before the returned promise\n    // is resolved and before starting the next `loop` repetition.\n    await new Promise<void>(resume => {\n      state.resumeQueue.add(resume)\n    })\n  }\n\n  const result = getCombinedResult<any>(ctrl, await Promise.all(promises))\n  if (loop && result.finished && !(isLoop && result.noop)) {\n    const nextProps = createLoopUpdate(props, loop, to)\n    if (nextProps) {\n      prepareKeys(ctrl, [nextProps])\n      return flushUpdate(ctrl, nextProps, true)\n    }\n  }\n  if (onResolve) {\n    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item))\n  }\n  return result\n}\n\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\nexport function getSprings<State extends Lookup>(\n  ctrl: Controller<State>,\n  props?: OneOrMore<ControllerUpdate<State>>\n) {\n  const springs = { ...ctrl.springs }\n  if (props) {\n    each(toArray(props), (props: any) => {\n      if (is.und(props.keys)) {\n        props = createUpdate(props)\n      }\n      if (!is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = { ...props, to: undefined }\n      }\n      prepareSprings(springs as any, props, key => {\n        return createSpring(key)\n      })\n    })\n  }\n  return springs\n}\n\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\nexport function setSprings(\n  ctrl: Controller,\n  springs: SpringValues<UnknownProps>\n) {\n  eachProp(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring\n      addFluidObserver(spring, ctrl)\n    }\n  })\n}\n\nfunction createSpring(key: string, observer?: FluidObserver<FrameValue.Event>) {\n  const spring = new SpringValue()\n  spring.key = key\n  if (observer) {\n    addFluidObserver(spring, observer)\n  }\n  return spring\n}\n\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\nfunction prepareSprings(\n  springs: SpringValues,\n  props: ControllerQueue[number],\n  create: (key: string) => SpringValue\n) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key))\n      spring['_prepareNode'](props)\n    })\n  }\n}\n\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\nfunction prepareKeys(ctrl: Controller<any>, queue: ControllerQueue[number][]) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl)\n    })\n  })\n}\n","import * as React from 'react'\nimport { useContext, PropsWithChildren } from 'react'\nimport { useMemoOne } from '@react-spring/shared'\n\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\nexport interface SpringContext {\n  /** Pause all new and existing animations. */\n  pause?: boolean\n  /** Force all new and existing animations to be immediate. */\n  immediate?: boolean\n}\n\nexport const SpringContext = ({\n  children,\n  ...props\n}: PropsWithChildren<SpringContext>) => {\n  const inherited = useContext(ctx)\n\n  // Inherited values are dominant when truthy.\n  const pause = props.pause || !!inherited.pause,\n    immediate = props.immediate || !!inherited.immediate\n\n  // Memoize the context to avoid unwanted renders.\n  props = useMemoOne(() => ({ pause, immediate }), [pause, immediate])\n\n  const { Provider } = ctx\n  return <Provider value={props}>{children}</Provider>\n}\n\nconst ctx = makeContext(SpringContext, {} as SpringContext)\n\n// Allow `useContext(SpringContext)` in TypeScript.\nSpringContext.Provider = ctx.Provider\nSpringContext.Consumer = ctx.Consumer\n\n/** Make the `target` compatible with `useContext` */\nfunction makeContext<T>(target: any, init: T): React.Context<T> {\n  Object.assign(target, React.createContext(init))\n  target.Provider._context = target\n  target.Consumer._context = target\n  return target\n}\n","import { each, is, deprecateDirectCall } from '@react-spring/shared'\nimport { Lookup, Falsy, OneOrMore } from '@react-spring/types'\nimport { AsyncResult, ControllerUpdate } from './types'\nimport { Controller } from './Controller'\n\ninterface ControllerUpdateFn<State extends Lookup = Lookup> {\n  (i: number, ctrl: Controller<State>): ControllerUpdate<State> | Falsy\n}\n\n/**\n * Extending from function allows SpringRef instances to be callable.\n * https://hackernoon.com/creating-callable-objects-in-javascript-d21l3te1\n *\n * ```js\n * const [springs, api] = useSpring(() => ({x: 0}))\n * api.start({x: 3}) // this works\n * api({x: 3}) // this also works (non breaking from 9rc3)\n * ```\n */\nexport class SpringRef<State extends Lookup = Lookup> extends Function {\n  readonly current: Controller<State>[] = []\n\n  constructor() {\n    super('return arguments.callee._call.apply(arguments.callee, arguments)')\n  }\n\n  /** @deprecated use the property 'start' instead */\n  _call(props?: ControllerUpdate<State> | ControllerUpdateFn<State>) {\n    deprecateDirectCall()\n    this.start(props)\n  }\n\n  /** Update the state of each controller without animating. */\n  set(values: Partial<State>) {\n    each(this.current, ctrl => ctrl.set(values))\n  }\n\n  /** Start the queued animations of each controller. */\n  start(): AsyncResult<Controller<State>>[]\n  /** Update every controller with the same props. */\n  start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]\n  /** Update controllers based on their state. */\n  start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]\n  /** Start animating each controller. */\n  start(\n    props?: ControllerUpdate<State> | ControllerUpdateFn<State>\n  ): AsyncResult<Controller<State>>[]\n  /** @internal */\n  start(props?: object | ControllerUpdateFn<State>) {\n    const results: AsyncResult[] = []\n\n    each(this.current, (ctrl, i) => {\n      if (is.und(props)) {\n        results.push(ctrl.start())\n      } else {\n        const update = this._getProps(props, ctrl, i)\n        if (update) {\n          results.push(ctrl.start(update))\n        }\n      }\n    })\n\n    return results\n  }\n\n  /** Add the same props to each controller's update queue. */\n  update(props: ControllerUpdate<State>): this\n  /** Generate separate props for each controller's update queue. */\n  update(props: ControllerUpdateFn<State>): this\n  /** Add props to each controller's update queue. */\n  update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this\n  /** @internal */\n  update(props: object | ControllerUpdateFn<State>) {\n    each(this.current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)))\n    return this\n  }\n\n  /** Add a controller to this ref */\n  add(ctrl: Controller<State>) {\n    if (!this.current.includes(ctrl)) {\n      this.current.push(ctrl)\n    }\n  }\n\n  /** Remove a controller from this ref */\n  delete(ctrl: Controller<State>) {\n    const i = this.current.indexOf(ctrl)\n    if (~i) this.current.splice(i, 1)\n  }\n\n  /** Overridden by `useTrail` to manipulate props */\n  protected _getProps(\n    arg: ControllerUpdate<State> | ControllerUpdateFn<State>,\n    ctrl: Controller<State>,\n    index: number\n  ): ControllerUpdate<State> | Falsy {\n    return is.fun(arg) ? arg(index, ctrl) : arg\n  }\n}\n\nexport interface SpringRef<State extends Lookup> {\n  (props?: ControllerUpdate<State> | ControllerUpdateFn<State>): AsyncResult<\n    Controller<State>\n  >[]\n  /** Stop all animations. */\n  stop(): this\n  /** Stop animations for the given keys. */\n  stop(keys: OneOrMore<string>): this\n  /** Cancel all animations. */\n  stop(cancel: boolean): this\n  /** Cancel animations for the given keys. */\n  stop(cancel: boolean, keys: OneOrMore<string>): this\n  /** Stop some or all animations. */\n  stop(keys?: OneOrMore<string>): this\n  /** Cancel some or all animations. */\n  stop(cancel: boolean, keys?: OneOrMore<string>): this\n\n  /** Pause all animations. */\n  pause(): this\n  /** Pause animations for the given keys. */\n  pause(keys: OneOrMore<string>): this\n  /** Pause some or all animations. */\n  pause(keys?: OneOrMore<string>): this\n\n  /** Resume all animations. */\n  resume(): this\n  /** Resume animations for the given keys. */\n  resume(keys: OneOrMore<string>): this\n  /** Resume some or all animations. */\n  resume(keys?: OneOrMore<string>): this\n}\n\neach(['stop', 'pause', 'resume'] as const, key => {\n  SpringRef.prototype[key] = function (this: SpringRef) {\n    each(this.current, ctrl => ctrl[key](...arguments))\n    return this\n  } as any\n})\n","import { useContext, useMemo, useRef } from 'react'\nimport { Lookup } from '@react-spring/types'\nimport {\n  is,\n  each,\n  usePrev,\n  useOnce,\n  useForceUpdate,\n  useLayoutEffect,\n} from '@react-spring/shared'\n\nimport {\n  ControllerFlushFn,\n  ControllerUpdate,\n  PickAnimated,\n  SpringValues,\n} from '../types'\nimport { UseSpringProps } from './useSpring'\nimport { declareUpdate } from '../SpringValue'\nimport {\n  Controller,\n  getSprings,\n  flushUpdateQueue,\n  setSprings,\n} from '../Controller'\nimport { hasProps, detachRefs, replaceRef } from '../helpers'\nimport { SpringContext } from '../SpringContext'\nimport { SpringRef } from '../SpringRef'\n\nexport type UseSpringsProps<State extends Lookup = Lookup> = unknown &\n  ControllerUpdate<State> & {\n    ref?: SpringRef<State>\n  }\n\n/**\n * When the `deps` argument exists, the `props` function is called whenever\n * the `deps` change on re-render.\n *\n * Without the `deps` argument, the `props` function is only called once.\n */\nexport function useSprings<Props extends UseSpringProps>(\n  length: number,\n  props: (i: number, ctrl: Controller) => Props,\n  deps?: readonly any[]\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State>[], SpringRef<State>]\n  : never\n\n/**\n * Animations are updated on re-render.\n */\nexport function useSprings<Props extends UseSpringsProps>(\n  length: number,\n  props: Props[] & UseSpringsProps<PickAnimated<Props>>[]\n): SpringValues<PickAnimated<Props>>[]\n\n/**\n * When the `deps` argument exists, you get the `update` and `stop` function.\n */\nexport function useSprings<Props extends UseSpringsProps>(\n  length: number,\n  props: Props[] & UseSpringsProps<PickAnimated<Props>>[],\n  deps: readonly any[] | undefined\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State>[], SpringRef<State>]\n  : never\n\n/** @internal */\nexport function useSprings(\n  length: number,\n  props: any[] | ((i: number, ctrl: Controller) => any),\n  deps?: readonly any[]\n): any {\n  const propsFn = is.fun(props) && props\n  if (propsFn && !deps) deps = []\n\n  // Create a local ref if a props function or deps array is ever passed.\n  const ref = useMemo(\n    () => (propsFn || arguments.length == 3 ? new SpringRef() : void 0),\n    []\n  )\n\n  interface State {\n    // The controllers used for applying updates.\n    ctrls: Controller[]\n    // The queue of changes to make on commit.\n    queue: Array<() => void>\n    // The flush function used by controllers.\n    flush: ControllerFlushFn\n  }\n\n  // Set to 0 to prevent sync flush.\n  const layoutId = useRef(0)\n  const forceUpdate = useForceUpdate()\n\n  // State is updated on commit.\n  const state = useMemo(\n    (): State => ({\n      ctrls: [],\n      queue: [],\n      flush(ctrl, updates) {\n        const springs = getSprings(ctrl, updates)\n\n        // Flushing is postponed until the component's commit phase\n        // if a spring was created since the last commit.\n        const canFlushSync =\n          layoutId.current > 0 &&\n          !state.queue.length &&\n          !Object.keys(springs).some(key => !ctrl.springs[key])\n\n        return canFlushSync\n          ? flushUpdateQueue(ctrl, updates)\n          : new Promise<any>(resolve => {\n              setSprings(ctrl, springs)\n              state.queue.push(() => {\n                resolve(flushUpdateQueue(ctrl, updates))\n              })\n              forceUpdate()\n            })\n      },\n    }),\n    []\n  )\n\n  const ctrls = [...state.ctrls]\n  const updates: any[] = []\n\n  // Cache old controllers to dispose in the commit phase.\n  const prevLength = usePrev(length) || 0\n  const oldCtrls = ctrls.slice(length, prevLength)\n\n  // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n  useMemo(() => {\n    ctrls.length = length\n    declareUpdates(prevLength, length)\n  }, [length])\n\n  // Update existing controllers when \"deps\" are changed.\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length))\n  }, deps)\n\n  /** Fill the `updates` array with declarative updates for the given index range. */\n  function declareUpdates(startIndex: number, endIndex: number) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush))\n\n      const update: UseSpringProps<any> = propsFn\n        ? propsFn(i, ctrl)\n        : (props as any)[i]\n\n      if (update) {\n        updates[i] = declareUpdate(update)\n      }\n    }\n  }\n\n  // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]))\n\n  const context = useContext(SpringContext)\n  const prevContext = usePrev(context)\n  const hasContext = context !== prevContext && hasProps(context)\n\n  useLayoutEffect(() => {\n    layoutId.current++\n\n    // Replace the cached controllers.\n    state.ctrls = ctrls\n\n    // Flush the commit queue.\n    const { queue } = state\n    if (queue.length) {\n      state.queue = []\n      each(queue, cb => cb())\n    }\n\n    // Clean up any unused controllers.\n    each(oldCtrls, ctrl => {\n      detachRefs(ctrl, ref)\n      ctrl.stop(true)\n    })\n\n    // Update existing controllers.\n    each(ctrls, (ctrl, i) => {\n      const values = springs[i]\n      setSprings(ctrl, values)\n\n      // Attach the controller to the local ref.\n      ref?.add(ctrl)\n\n      // Update the default props.\n      if (hasContext) {\n        ctrl.start({ default: context })\n      }\n\n      // Apply updates created during render.\n      const update = updates[i]\n      if (update) {\n        // Update the injected ref if needed.\n        replaceRef(ctrl, update.ref)\n\n        // When an injected ref exists, the update is postponed\n        // until the ref has its `start` method called.\n        if (ctrl.ref) {\n          ctrl.queue.push(update)\n        } else {\n          ctrl.start(update)\n        }\n      }\n    })\n  })\n\n  // Cancel the animations of all controllers on unmount.\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.stop(true))\n  })\n\n  // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n  const values = springs.map(x => ({ ...x }))\n\n  return ref ? [values, ref] : values\n}\n","import { Remap } from '@react-spring/types'\nimport { is } from '@react-spring/shared'\n\nimport { ControllerUpdate, PickAnimated, SpringValues } from '../types'\nimport { Valid } from '../types/common'\nimport { SpringRef } from '../SpringRef'\nimport { useSprings } from './useSprings'\n\n/**\n * The props that `useSpring` recognizes.\n */\nexport type UseSpringProps<Props extends object = any> = unknown &\n  PickAnimated<Props> extends infer State\n  ? Remap<\n      ControllerUpdate<State> & {\n        /**\n         * Used to access the imperative API.\n         *\n         * When defined, the render animation won't auto-start.\n         */\n        ref?: SpringRef<State>\n      }\n    >\n  : never\n\n/**\n * The `props` function is only called on the first render, unless\n * `deps` change (when defined). State is inferred from forward props.\n */\nexport function useSpring<Props extends object>(\n  props:\n    | Function\n    | (() => (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps),\n  deps?: readonly any[] | undefined\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State>, SpringRef<State>]\n  : never\n\n/**\n * Updated on every render, with state inferred from forward props.\n */\nexport function useSpring<Props extends object>(\n  props: (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps\n): SpringValues<PickAnimated<Props>>\n\n/**\n * Updated only when `deps` change, with state inferred from forward props.\n */\nexport function useSpring<Props extends object>(\n  props: (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps,\n  deps: readonly any[] | undefined\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State>, SpringRef<State>]\n  : never\n\n/** @internal */\nexport function useSpring(props: any, deps?: readonly any[]) {\n  const isFn = is.fun(props)\n  const [[values], ref] = useSprings(\n    1,\n    isFn ? props : [props],\n    isFn ? deps || [] : deps\n  )\n  return isFn || arguments.length == 2 ? [values, ref] : values\n}\n","import { useState } from 'react'\nimport { Lookup } from '@react-spring/types'\nimport { SpringRef } from '../SpringRef'\n\nconst initSpringRef = () => new SpringRef<any>()\n\nexport const useSpringRef = <State extends Lookup = Lookup>() =>\n  useState(initSpringRef)[0] as SpringRef<State>\n","import { each, is, useLayoutEffect } from '@react-spring/shared'\n\nimport { Valid } from '../types/common'\nimport { PickAnimated, SpringValues } from '../types'\nimport { UseSpringProps } from './useSpring'\nimport { SpringRef } from '../SpringRef'\nimport { Controller } from '../Controller'\nimport { useSprings } from './useSprings'\n\nexport type UseTrailProps<Props extends object = any> = UseSpringProps<Props>\n\nexport function useTrail<Props extends object>(\n  length: number,\n  props: (\n    i: number,\n    ctrl: Controller\n  ) => UseTrailProps | (Props & Valid<Props, UseTrailProps<Props>>),\n  deps?: readonly any[]\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State>[], SpringRef<State>]\n  : never\n\nexport function useTrail<Props extends object>(\n  length: number,\n  props: UseTrailProps | (Props & Valid<Props, UseTrailProps<Props>>)\n): SpringValues<PickAnimated<Props>>[]\n\nexport function useTrail<Props extends object>(\n  length: number,\n  props: UseTrailProps | (Props & Valid<Props, UseTrailProps<Props>>),\n  deps: readonly any[]\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State>[], SpringRef<State>]\n  : never\n\nexport function useTrail(\n  length: number,\n  propsArg: unknown,\n  deps?: readonly any[]\n) {\n  const propsFn = is.fun(propsArg) && propsArg\n  if (propsFn && !deps) deps = []\n\n  // The trail is reversed when every render-based update is reversed.\n  let reverse = true\n\n  const result = useSprings(\n    length,\n    (i, ctrl) => {\n      const props = propsFn ? propsFn(i, ctrl) : propsArg\n      reverse = reverse && props.reverse\n      return props\n    },\n    // Ensure the props function is called when no deps exist.\n    // This works around the 3 argument rule.\n    deps || [{}]\n  )\n\n  const ref = result[1]\n\n  useLayoutEffect(() => {\n    each(ref.current, (ctrl, i) => {\n      const parent = ref.current[i + (reverse ? 1 : -1)]\n      if (parent) ctrl.start({ to: parent.springs })\n    })\n  }, deps)\n\n  if (propsFn || arguments.length == 3) {\n    ref['_getProps'] = (propsArg, ctrl, i) => {\n      const props = is.fun(propsArg) ? propsArg(i, ctrl) : propsArg\n      if (props) {\n        const parent = ref.current[i + (props.reverse ? 1 : -1)]\n        if (parent) props.to = parent.springs\n        return props\n      }\n    }\n    return result\n  }\n  return result[0]\n}\n","// TODO: convert to \"const enum\" once Babel supports it\nexport type TransitionPhase =\n  | typeof MOUNT\n  | typeof ENTER\n  | typeof UPDATE\n  | typeof LEAVE\n\n/** This transition is being mounted */\nexport const MOUNT = 'mount'\n\n/** This transition is entering or has entered */\nexport const ENTER = 'enter'\n\n/** This transition had its animations updated */\nexport const UPDATE = 'update'\n\n/** This transition will expire after animating */\nexport const LEAVE = 'leave'\n","import * as React from 'react'\nimport { useContext, useRef, useMemo } from 'react'\nimport { OneOrMore, UnknownProps } from '@react-spring/types'\nimport {\n  is,\n  toArray,\n  useForceUpdate,\n  useOnce,\n  usePrev,\n  each,\n  useLayoutEffect,\n} from '@react-spring/shared'\n\nimport {\n  Change,\n  ControllerUpdate,\n  ItemKeys,\n  PickAnimated,\n  TransitionFn,\n  TransitionState,\n  TransitionTo,\n  UseTransitionProps,\n} from '../types'\nimport { Valid } from '../types/common'\nimport {\n  callProp,\n  detachRefs,\n  getDefaultProps,\n  hasProps,\n  inferTo,\n  replaceRef,\n} from '../helpers'\nimport { Controller, getSprings, setSprings } from '../Controller'\nimport { SpringContext } from '../SpringContext'\nimport { SpringRef } from '../SpringRef'\nimport {\n  ENTER,\n  MOUNT,\n  LEAVE,\n  UPDATE,\n  TransitionPhase,\n} from '../TransitionPhase'\n\ndeclare function setTimeout(handler: Function, timeout?: number): number\ndeclare function clearTimeout(timeoutId: number): void\n\nexport function useTransition<Item, Props extends object>(\n  data: OneOrMore<Item>,\n  props:\n    | UseTransitionProps<Item>\n    | (Props & Valid<Props, UseTransitionProps<Item>>)\n): TransitionFn<Item, PickAnimated<Props>>\n\nexport function useTransition<Item, Props extends object>(\n  data: OneOrMore<Item>,\n  props:\n    | UseTransitionProps<Item>\n    | (Props & Valid<Props, UseTransitionProps<Item>>),\n  deps: any[] | undefined\n): PickAnimated<Props> extends infer State\n  ? [TransitionFn<Item, State>, SpringRef<State>]\n  : never\n\nexport function useTransition(\n  data: unknown,\n  props: UseTransitionProps,\n  deps?: any[]\n): any {\n  const { reset, sort, trail = 0, expires = true, onDestroyed } = props\n\n  // Return a `SpringRef` if a deps array was passed.\n  const ref = useMemo(\n    () => (arguments.length == 3 ? new SpringRef() : void 0),\n    []\n  )\n\n  // Every item has its own transition.\n  const items = toArray(data)\n  const transitions: TransitionState[] = []\n\n  // The \"onRest\" callbacks need a ref to the latest transitions.\n  const usedTransitions = useRef<TransitionState[] | null>(null)\n  const prevTransitions = reset ? null : usedTransitions.current\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions\n  })\n\n  // Destroy all transitions on dismount.\n  useOnce(() => () =>\n    each(usedTransitions.current!, t => {\n      if (t.expired) {\n        clearTimeout(t.expirationId!)\n      }\n      detachRefs(t.ctrl, ref)\n      t.ctrl.stop(true)\n    })\n  )\n\n  // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n  const keys = getKeys(items, props, prevTransitions)\n\n  // Expired transitions that need clean up.\n  const expired = (reset && usedTransitions.current) || []\n  useLayoutEffect(() =>\n    each(expired, ({ ctrl, item, key }) => {\n      detachRefs(ctrl, ref)\n      callProp(onDestroyed, item, key)\n    })\n  )\n\n  // Map old indices to new indices.\n  const reused: number[] = []\n  if (prevTransitions)\n    each(prevTransitions, (t, i) => {\n      // Expired transitions are not rendered.\n      if (t.expired) {\n        clearTimeout(t.expirationId!)\n        expired.push(t)\n      } else {\n        i = reused[i] = keys.indexOf(t.key)\n        if (~i) transitions[i] = t\n      }\n    })\n\n  // Mount new items with fresh transitions.\n  each(items, (item, i) => {\n    if (!transitions[i]) {\n      transitions[i] = {\n        key: keys[i],\n        item,\n        phase: MOUNT,\n        ctrl: new Controller(),\n      }\n\n      transitions[i].ctrl.item = item\n    }\n  })\n\n  // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n  if (reused.length) {\n    let i = -1\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions![prevIndex]\n      if (~keyIndex) {\n        i = transitions.indexOf(t)\n        transitions[i] = { ...t, item: items[keyIndex] }\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t)\n      }\n    })\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item))\n  }\n\n  // Track cumulative delay for the \"trail\" prop.\n  let delay = -trail\n\n  // Expired transitions use this to dismount.\n  const forceUpdate = useForceUpdate()\n\n  // These props are inherited by every phase change.\n  const defaultProps = getDefaultProps<UseTransitionProps>(props)\n  // Generate changes to apply in useEffect.\n  const changes = new Map<TransitionState, Change>()\n  each(transitions, (t, i) => {\n    const key = t.key\n    const prevPhase = t.phase\n\n    let to: TransitionTo<any>\n    let phase: TransitionPhase\n    if (prevPhase == MOUNT) {\n      to = props.enter\n      phase = ENTER\n    } else {\n      const isLeave = keys.indexOf(key) < 0\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave\n          phase = LEAVE\n        } else if ((to = props.update)) {\n          phase = UPDATE\n        } else return\n      } else if (!isLeave) {\n        to = props.enter\n        phase = ENTER\n      } else return\n    }\n\n    // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n    to = callProp(to, t.item, i)\n    to = is.obj(to) ? inferTo(to) : { to }\n\n    if (!to.config) {\n      const config = props.config || defaultProps.config\n      to.config = callProp(config, t.item, i, phase)\n    }\n\n    // The payload is used to update the spring props once the current render is committed.\n    const payload: ControllerUpdate<UnknownProps> = {\n      ...defaultProps,\n      delay: (delay += trail),\n      // This prevents implied resets.\n      reset: false,\n      // Merge any phase-specific props.\n      ...(to as any),\n    }\n\n    if (phase == ENTER && is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      const from =\n        is.und(props.initial) || prevTransitions ? props.from : props.initial\n\n      payload.from = callProp(from, t.item, i)\n    }\n\n    const { onResolve } = payload\n    payload.onResolve = result => {\n      callProp(onResolve, result)\n\n      const transitions = usedTransitions.current!\n      const t = transitions.find(t => t.key === key)\n      if (!t) return\n\n      if (result.cancelled && t.phase != UPDATE) {\n        /**\n         * @legacy Reset the phase of a cancelled enter/leave transition, so it can\n         * retry the animation on the next render.\n         *\n         * Note: leaving this here made the transitioned item respawn.\n         */\n        // t.phase = prevPhase\n        return\n      }\n\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle)\n        if (t.phase == LEAVE) {\n          const expiry = callProp(expires, t.item)\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry\n            t.expired = true\n\n            // Force update once the expiration delay ends.\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff)\n                t.expirationId = setTimeout(forceUpdate, expiryMs)\n              return\n            }\n          }\n        }\n        // Force update once idle and expired items exist.\n        if (idle && transitions.some(t => t.expired)) {\n          forceUpdate()\n        }\n      }\n    }\n\n    const springs = getSprings(t.ctrl, payload)\n    changes.set(t, { phase, springs, payload })\n  })\n\n  // The prop overrides from an ancestor.\n  const context = useContext(SpringContext)\n  const prevContext = usePrev(context)\n  const hasContext = context !== prevContext && hasProps(context)\n\n  // Merge the context into each transition.\n  useLayoutEffect(() => {\n    if (hasContext)\n      each(transitions, t => {\n        t.ctrl.start({ default: context })\n      })\n  }, [context])\n\n  useLayoutEffect(\n    () => {\n      each(changes, ({ phase, springs, payload }, t) => {\n        const { ctrl } = t\n        t.phase = phase\n\n        // Attach the controller to our local ref.\n        ref?.add(ctrl)\n\n        // Update the injected ref if needed.\n        replaceRef(ctrl, payload.ref)\n\n        // Save any springs created this render.\n        setSprings(ctrl, springs)\n\n        // Merge the context into new items.\n        if (hasContext && phase == ENTER) {\n          ctrl.start({ default: context })\n        }\n\n        // Postpone the update if an injected ref exists.\n        ctrl[ctrl.ref ? 'update' : 'start'](payload)\n      })\n    },\n    reset ? void 0 : deps\n  )\n\n  const renderTransitions: TransitionFn = render => (\n    <>\n      {transitions.map((t, i) => {\n        const { springs } = changes.get(t) || t.ctrl\n        const elem: any = render({ ...springs }, t.item, t, i)\n        return elem && elem.type ? (\n          <elem.type\n            {...elem.props}\n            key={is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id}\n            ref={elem.ref}\n          />\n        ) : (\n          elem\n        )\n      })}\n    </>\n  )\n\n  return ref ? [renderTransitions, ref] : renderTransitions\n}\n\n/** Local state for auto-generated item keys */\nlet nextKey = 1\n\nfunction getKeys(\n  items: readonly any[],\n  { key, keys = key }: { key?: ItemKeys; keys?: ItemKeys },\n  prevTransitions: TransitionState[] | null\n): readonly any[] {\n  if (keys === null) {\n    const reused = new Set()\n    return items.map(item => {\n      const t =\n        prevTransitions &&\n        prevTransitions.find(\n          t => t.item === item && t.phase !== LEAVE && !reused.has(t)\n        )\n      if (t) {\n        reused.add(t)\n        return t.key\n      }\n      return nextKey++\n    })\n  }\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys)\n}\n","import { NoInfer, UnknownProps } from '@react-spring/types'\nimport { useSpring, UseSpringProps } from '../hooks/useSpring'\nimport { SpringValues, SpringToFn, SpringChain } from '../types'\n\nexport type SpringComponentProps<\n  State extends object = UnknownProps\n> = unknown &\n  UseSpringProps<State> & {\n    children: (values: SpringValues<State>) => JSX.Element | null\n  }\n\n// Infer state from \"from\" object prop.\nexport function Spring<State extends object>(\n  props: {\n    from: State\n    to?: SpringChain<NoInfer<State>> | SpringToFn<NoInfer<State>>\n  } & Omit<SpringComponentProps<NoInfer<State>>, 'from' | 'to'>\n): JSX.Element | null\n\n// Infer state from \"to\" object prop.\nexport function Spring<State extends object>(\n  props: { to: State } & Omit<SpringComponentProps<NoInfer<State>>, 'to'>\n): JSX.Element | null\n\nexport function Spring({ children, ...props }: any) {\n  return children(useSpring(props))\n}\n","import { ReactNode } from 'react'\nimport { NoInfer, Falsy } from '@react-spring/types'\nimport { is } from '@react-spring/shared'\n\nimport { Valid } from '../types/common'\nimport { PickAnimated, SpringValues } from '../types'\nimport { UseSpringProps } from '../hooks/useSpring'\nimport { useTrail } from '../hooks/useTrail'\n\nexport type TrailComponentProps<Item, Props extends object = any> = unknown &\n  UseSpringProps<Props> & {\n    items: readonly Item[]\n    children: (\n      item: NoInfer<Item>,\n      index: number\n    ) => ((values: SpringValues<PickAnimated<Props>>) => ReactNode) | Falsy\n  }\n\nexport function Trail<Item, Props extends TrailComponentProps<Item>>({\n  items,\n  children,\n  ...props\n}: Props & Valid<Props, TrailComponentProps<Item, Props>>) {\n  const trails: any[] = useTrail(items.length, props)\n  return items.map((item, index) => {\n    const result = children(item, index)\n    return is.fun(result) ? result(trails[index]) : result\n  })\n}\n","import { Valid } from '../types/common'\nimport { TransitionComponentProps } from '../types'\nimport { useTransition } from '../hooks'\n\nexport function Transition<\n  Item extends any,\n  Props extends TransitionComponentProps<Item>\n>(\n  props:\n    | TransitionComponentProps<Item>\n    | (Props & Valid<Props, TransitionComponentProps<Item, Props>>)\n): JSX.Element\n\nexport function Transition({\n  items,\n  children,\n  ...props\n}: TransitionComponentProps<any>) {\n  return useTransition(items, props)(children)\n}\n","import { Arrify, InterpolatorArgs, InterpolatorFn } from '@react-spring/types'\nimport {\n  is,\n  raf,\n  each,\n  isEqual,\n  toArray,\n  frameLoop,\n  FluidValue,\n  getFluidValue,\n  createInterpolator,\n  Globals as G,\n  callFluidObservers,\n  addFluidObserver,\n  removeFluidObserver,\n  hasFluidValue,\n} from '@react-spring/shared'\n\nimport { FrameValue, isFrameValue } from './FrameValue'\nimport {\n  getAnimated,\n  setAnimated,\n  getAnimatedType,\n  getPayload,\n} from '@react-spring/animated'\n\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\nexport class Interpolation<In = any, Out = any> extends FrameValue<Out> {\n  /** Useful for debugging. */\n  key?: string\n\n  /** Equals false when in the frameloop */\n  idle = true\n\n  /** The function that maps inputs values to output */\n  readonly calc: InterpolatorFn<In, Out>\n\n  /** The inputs which are currently animating */\n  protected _active = new Set<FluidValue>()\n\n  constructor(\n    /** The source of input values */\n    readonly source: unknown,\n    args: InterpolatorArgs<In, Out>\n  ) {\n    super()\n    this.calc = createInterpolator(...args)\n\n    const value = this._get()\n    const nodeType = getAnimatedType(value)\n\n    // Assume the computed value never changes type.\n    setAnimated(this, nodeType.create(value))\n  }\n\n  advance(_dt?: number) {\n    const value = this._get()\n    const oldValue = this.get()\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this)!.setValue(value)\n      this._onChange(value, this.idle)\n    }\n    // Become idle when all parents are idle or paused.\n    if (!this.idle && checkIdle(this._active)) {\n      becomeIdle(this)\n    }\n  }\n\n  protected _get() {\n    const inputs: Arrify<In> = is.arr(this.source)\n      ? this.source.map(getFluidValue)\n      : (toArray(getFluidValue(this.source)) as any)\n\n    return this.calc(...inputs)\n  }\n\n  protected _start() {\n    if (this.idle && !checkIdle(this._active)) {\n      this.idle = false\n\n      each(getPayload(this)!, node => {\n        node.done = false\n      })\n\n      if (G.skipAnimation) {\n        raf.batchedUpdates(() => this.advance())\n        becomeIdle(this)\n      } else {\n        frameLoop.start(this)\n      }\n    }\n  }\n\n  // Observe our sources only when we're observed.\n  protected _attach() {\n    let priority = 1\n    each(toArray(this.source), source => {\n      if (hasFluidValue(source)) {\n        addFluidObserver(source, this)\n      }\n      if (isFrameValue(source)) {\n        if (!source.idle) {\n          this._active.add(source)\n        }\n        priority = Math.max(priority, source.priority + 1)\n      }\n    })\n    this.priority = priority\n    this._start()\n  }\n\n  // Stop observing our sources once we have no observers.\n  protected _detach() {\n    each(toArray(this.source), source => {\n      if (hasFluidValue(source)) {\n        removeFluidObserver(source, this)\n      }\n    })\n    this._active.clear()\n    becomeIdle(this)\n  }\n\n  /** @internal */\n  eventObserved(event: FrameValue.Event) {\n    // Update our value when an idle parent is changed,\n    // and enter the frameloop when a parent is resumed.\n    if (event.type == 'change') {\n      if (event.idle) {\n        this.advance()\n      } else {\n        this._active.add(event.parent)\n        this._start()\n      }\n    }\n    // Once all parents are idle, the `advance` method runs one more time,\n    // so we should avoid updating the `idle` status here.\n    else if (event.type == 'idle') {\n      this._active.delete(event.parent)\n    }\n    // Ensure our priority is greater than all parents, which means\n    // our value won't be updated until our parents have updated.\n    else if (event.type == 'priority') {\n      this.priority = toArray(this.source).reduce(\n        (highest: number, parent) =>\n          Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),\n        0\n      )\n    }\n  }\n}\n\n/** Returns true for an idle source. */\nfunction isIdle(source: any) {\n  return source.idle !== false\n}\n\n/** Return true if all values in the given set are idle or paused. */\nfunction checkIdle(active: Set<FluidValue>) {\n  // Parents can be active even when paused, so the `.every` check\n  // removes us from the frameloop if all active parents are paused.\n  return !active.size || Array.from(active).every(isIdle)\n}\n\n/** Become idle if not already idle. */\nfunction becomeIdle(self: Interpolation) {\n  if (!self.idle) {\n    self.idle = true\n\n    each(getPayload(self)!, node => {\n      node.done = true\n    })\n\n    callFluidObservers(self, {\n      type: 'idle',\n      parent: self,\n    })\n  }\n}\n","import { FluidValue, deprecateInterpolate } from '@react-spring/shared'\nimport {\n  Constrain,\n  OneOrMore,\n  Animatable,\n  ExtrapolateType,\n  InterpolatorConfig,\n  InterpolatorFn,\n} from '@react-spring/types'\nimport { Interpolation } from './Interpolation'\n\n/** Map the value of one or more dependencies */\nexport const to: Interpolator = (source: any, ...args: [any]) =>\n  new Interpolation(source, args)\n\n/** @deprecated Use the `to` export instead */\nexport const interpolate: Interpolator = (source: any, ...args: [any]) => (\n  deprecateInterpolate(), new Interpolation(source, args)\n)\n\n/** Extract the raw value types that are being interpolated */\nexport type Interpolated<T extends ReadonlyArray<any>> = {\n  [P in keyof T]: T[P] extends infer Element\n    ? Element extends FluidValue<infer U>\n      ? U\n      : Element\n    : never\n}\n\n/**\n * This interpolates one or more `FluidValue` objects.\n * The exported `interpolate` function uses this type.\n */\nexport interface Interpolator {\n  // Tuple of parent values\n  <In extends ReadonlyArray<any>, Out>(\n    parents: In,\n    interpolator: (...args: Interpolated<In>) => Out\n  ): Interpolation<Out>\n\n  // Single parent value\n  <In, Out>(\n    parent: FluidValue<In> | In,\n    interpolator: InterpolatorFn<In, Out>\n  ): Interpolation<Out>\n\n  // Interpolation config\n  <Out>(\n    parents: OneOrMore<FluidValue>,\n    config: InterpolatorConfig<Out>\n  ): Interpolation<Animatable<Out>>\n\n  // Range shortcuts\n  <Out>(\n    parents: OneOrMore<FluidValue<number>> | FluidValue<number[]>,\n    range: readonly number[],\n    output: readonly Constrain<Out, Animatable>[],\n    extrapolate?: ExtrapolateType\n  ): Interpolation<Animatable<Out>>\n}\n","import {\n  Globals,\n  frameLoop,\n  createStringInterpolator,\n} from '@react-spring/shared'\nimport { Interpolation } from './Interpolation'\n\n// Sane defaults\nGlobals.assign({\n  createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args),\n})\n\nexport { Globals }\n\n/** Advance all animations by the given time */\nexport const update = frameLoop.advance\n"]},"metadata":{},"sourceType":"module"}